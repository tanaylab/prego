[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 Weizmann Institute Science Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Aviezer Lifshitz. Author, maintainer. Amos Tanay. Author.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lifshitz , Tanay (2024). prego: PWM Regression Optimizer. R package version 0.0.3.","code":"@Manual{,   title = {prego: PWM Regression Optimizer},   author = {Aviezer Lifshitz and Amos Tanay},   year = {2024},   note = {R package version 0.0.3}, }"},{"path":"/index.html","id":"prego","dir":"","previous_headings":"","what":"PWM Regression Optimizer","title":"PWM Regression Optimizer","text":"prego package implements simple regression algorithms finding motifs DNA. can either use find motif discriminating two clusters DNA sequences, generating motifs one continuous variables. PREGO algorithm described .","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"PWM Regression Optimizer","text":"can install development version prego like :","code":"remotes::install_github(\"tanaylab/prego\")"},{"path":"/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"PWM Regression Optimizer","text":"set continuous variables:  binary response:  clusters sequences:","code":"library(prego) #> ℹ Parallelization enabled. Using 77 threads. res <- regress_pwm(sequences_example, response_mat_example) #> ℹ Using \"r2\" as the final metric #> ℹ Number of response variables: 5 #>  #> ── Generate candidate kmers #>  #> ── Regress each candidate kmer #> ℹ Running regression on 10 candidate kmers #> • Bidirectional: TRUE #> • Spat bin size: 40 #> • Number of spatial bins 7 #> • Length of sequence: 280 #> • Min gap: 0 #> • Max gap: 1 #> • Kmer length: 8 #> • Improve epsilon: 1e-04 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> • kmer: \"TTTACAAC\", score (r2): 0.0126890005368537 #> • kmer: \"TA*CTGCTG\", score (r2): 0.00334159650449452 #> • kmer: \"AACCATCT\", score (r2): 0.0643097230120355 #> • kmer: \"AGA*AAGAA\", score (r2): 0.060384757659326 #> • kmer: \"TTATC*TCT\", score (r2): 0.0657310811484614 #> • kmer: \"TCACCTTG\", score (r2): 0.0623381197705449 #> • kmer: \"CTCTGCAG\", score (r2): 0.0677598761958694 #> • kmer: \"TAGCTGTC\", score (r2): 0.0640768115164421 #> • kmer: \"GACAAT*CT\", score (r2): 0.0607251519441225 #> • kmer: \"TCTTATCT\", score (r2): 0.0628163788281552 #> ℹ Best match in the database: \"JASPAR.ct\", cor: 0.667 #> ℹ Best motif: \"***CTCTGCAG****\", score (r2): 0.0677598761958694 plot_regression_qc(res) #> Warning: The `<scale>` argument of `guides()` cannot be `FALSE`. Use \"none\" instead as #> of ggplot2 3.3.4. #> ℹ The deprecated feature was likely used in the ggseqlogo package. #>   Please report the issue at <https://github.com/omarwagih/ggseqlogo/issues>. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated. res_binary <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1]) #> ℹ Using \"ks\" as the final metric #> ℹ Number of response variables: 1 #>  #> ── Generate candidate kmers #>  #> ── Regress each candidate kmer #> ℹ Running regression on 10 candidate kmers #> • Bidirectional: TRUE #> • Spat bin size: 40 #> • Number of spatial bins 7 #> • Length of sequence: 280 #> • Min gap: 0 #> • Max gap: 1 #> • Kmer length: 8 #> • Improve epsilon: 1e-04 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> • kmer: \"TTAAT*ATT\", score (ks): 0.854878919705105 #> • kmer: \"AAT*ATTAA\", score (ks): 0.854878919705105 #> • kmer: \"TAAT*ATTA\", score (ks): 0.843301065576269 #> • kmer: \"GTTAAT*AT\", score (ks): 0.844482257088238 #> • kmer: \"AT*ATTAAC\", score (ks): 0.844482257088238 #> • kmer: \"AA*CATTAA\", score (ks): 0.84950858078479 #> • kmer: \"TTAA*CATT\", score (ks): 0.849192870611084 #> • kmer: \"TAATCATT\", score (ks): 0.841995767306361 #> • kmer: \"TTA*TCATT\", score (ks): 0.845127829960678 #> • kmer: \"TAA*CATTA\", score (ks): 0.833248418183164 #> ℹ Best match in the database: \"JOLMA.HNF1B_di_full_1\", cor: 0.8 #> ✔ \"JOLMA.HNF1B_di_full_1\" KS test D: 0.8512, p-value: 0 #> ℹ Best motif: \"***TTAAT*ATT***\", score (ks): 0.854878919705105 plot_regression_qc(res_binary) res <- regress_pwm.clusters(cluster_sequences_example, clusters_example) #> ℹ Using sampled optimization #> ℹ Running regression for 5 clusters #> ℹ Matching with motif databases res$stats #> # A tibble: 5 × 7 #>   cluster consensus  ks_D    r2 seed_motif      db_match                 db_ma…¹ #>   <chr>   <chr>     <dbl> <dbl> <chr>           <chr>                      <dbl> #> 1 c100    GA***AT   0.668 0.326 ***TGATGG*TG*** HOCOMOCO.PDX1_HUMAN.H11…   0.786 #> 2 c111    Y**TAAA   0.836 0.514 ***GC*ATAAAA*** JOLMA.CDX2_mono_DBD        0.889 #> 3 c29     T*A***W*Y 0.830 0.552 ***TTAA*CATT*** JOLMA.HNF1B_di_full_1      0.745 #> 4 c5      <NA>      0.569 0.194 ***TGAT*GATG*** JASPAR.CG15696-RA          0.725 #> 5 c6      ATC       0.606 0.262 ***TCTTATCT**** HOMER.Gata2                0.864 #> # … with abbreviated variable name ¹​db_match_cor"},{"path":"/reference/HOCOMOCO_motifs.html","id":null,"dir":"Reference","previous_headings":"","what":"PSSMs from the HOCOMOCO motif database — HOCOMOCO_motifs","title":"PSSMs from the HOCOMOCO motif database — HOCOMOCO_motifs","text":"PSSMs HOCOMOCO motif database","code":""},{"path":"/reference/HOCOMOCO_motifs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PSSMs from the HOCOMOCO motif database — HOCOMOCO_motifs","text":"","code":"HOCOMOCO_motifs"},{"path":"/reference/HOCOMOCO_motifs.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"PSSMs from the HOCOMOCO motif database — HOCOMOCO_motifs","text":"data frame containing PSSMs ('', 'C', 'G' 'T' columns), additional column 'motif' containing motif name.","code":""},{"path":"/reference/HOCOMOCO_motifs.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"PSSMs from the HOCOMOCO motif database — HOCOMOCO_motifs","text":"https://hocomoco11.autosome.ru/downloads/","code":""},{"path":"/reference/HOCOMOCO_motifs.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"PSSMs from the HOCOMOCO motif database — HOCOMOCO_motifs","text":"Ivan V. Kulakovskiy; Ilya E. Vorontsov; Ivan S. Yevshin; Ruslan N. Sharipov; Alla D. Fedorova; Eugene . Rumynskiy; Yulia . Medvedeva; Arturo Magana-Mora; Vladimir B. Bajic; Dmitry . Papatsenko; Fedor . Kolpakov; Vsevolod J. Makeev: HOCOMOCO: towards complete collection transcription factor binding models human mouse via large-scale ChIP-Seq analysis. Nucl. Acids Res., Database issue, gkx1106 (11 November 2017). https://doi.org/10.1093/nar/gkx1106","code":""},{"path":"/reference/HOMER_motifs.html","id":null,"dir":"Reference","previous_headings":"","what":"PSSMs from the HOMER motif database — HOMER_motifs","title":"PSSMs from the HOMER motif database — HOMER_motifs","text":"PSSMs HOMER motif database","code":""},{"path":"/reference/HOMER_motifs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PSSMs from the HOMER motif database — HOMER_motifs","text":"","code":"HOMER_motifs"},{"path":"/reference/HOMER_motifs.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"PSSMs from the HOMER motif database — HOMER_motifs","text":"data frame containing PSSMs ('', 'C', 'G' 'T' columns), additional column 'motif' containing motif name.","code":""},{"path":"/reference/HOMER_motifs.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"PSSMs from the HOMER motif database — HOMER_motifs","text":"http://homer.ucsd.edu/homer/motif/","code":""},{"path":"/reference/HOMER_motifs.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"PSSMs from the HOMER motif database — HOMER_motifs","text":"Heinz S, Benner C, Spann N, Bertolino E et al. Simple Combinations Lineage-Determining Transcription Factors Prime cis-Regulatory Elements Required Macrophage B Cell Identities. Mol Cell 2010 May 28;38(4):576-589. PMID: 20513432","code":""},{"path":"/reference/JASPAR_motifs.html","id":null,"dir":"Reference","previous_headings":"","what":"PSSMs from the JASPAR motif database — JASPAR_motifs","title":"PSSMs from the JASPAR motif database — JASPAR_motifs","text":"PSSMs JASPAR motif database","code":""},{"path":"/reference/JASPAR_motifs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PSSMs from the JASPAR motif database — JASPAR_motifs","text":"","code":"JASPAR_motifs"},{"path":"/reference/JASPAR_motifs.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"PSSMs from the JASPAR motif database — JASPAR_motifs","text":"data frame containing PSSMs ('', 'C', 'G' 'T' columns), additional column 'motif' containing motif name.","code":""},{"path":"/reference/JASPAR_motifs.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"PSSMs from the JASPAR motif database — JASPAR_motifs","text":"https://jaspar.genereg.net/downloads/","code":""},{"path":"/reference/JASPAR_motifs.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"PSSMs from the JASPAR motif database — JASPAR_motifs","text":"Castro-Mondragon JA, Riudavets-Puig R, Rauluseviciute , Berhanu Lemma R, Turchi L, Blanc-Mathieu R, Lucas J, Boddie P, Khan , Manosalva Pérez N, Fornes O, Leung TY, Aguirre , Hammal F, Schmelter D, Baranasic D, Ballester B, Sandelin , Lenhard B, Vandepoele K, Wasserman WW, Parcy F, Mathelier JASPAR 2022: 9th release open-access database transcription factor binding profiles Nucleic Acids Res. 2022 Jan 7;50(D1):D165-D173.; doi: 10.1093/nar/gkab1113","code":""},{"path":"/reference/JOLMA_motifs.html","id":null,"dir":"Reference","previous_headings":"","what":"PSSMs from the Jolma et al. motif database — JOLMA_motifs","title":"PSSMs from the Jolma et al. motif database — JOLMA_motifs","text":"PSSMs Jolma et al. motif database","code":""},{"path":"/reference/JOLMA_motifs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PSSMs from the Jolma et al. motif database — JOLMA_motifs","text":"","code":"JOLMA_motifs"},{"path":"/reference/JOLMA_motifs.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"PSSMs from the Jolma et al. motif database — JOLMA_motifs","text":"data frame containing PSSMs ('', 'C', 'G' 'T' columns), additional column 'motif' containing motif name.","code":""},{"path":"/reference/JOLMA_motifs.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"PSSMs from the Jolma et al. motif database — JOLMA_motifs","text":"https://doi.org/10.1038/nature18912","code":""},{"path":"/reference/JOLMA_motifs.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"PSSMs from the Jolma et al. motif database — JOLMA_motifs","text":"Jolma, ., Yin, Y., Nitta, K. et al. DNA-dependent formation transcription factor pairs alters binding specificity. Nature 534, S15–S16 (2016). https://doi.org/10.1038/nature18912","code":""},{"path":"/reference/MOTIF_DB.html","id":null,"dir":"Reference","previous_headings":"","what":"A MotifDB object with motifs from all bundled databases — MOTIF_DB","title":"A MotifDB object with motifs from all bundled databases — MOTIF_DB","text":"MotifDB object motifs bundled databases","code":""},{"path":"/reference/MOTIF_DB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A MotifDB object with motifs from all bundled databases — MOTIF_DB","text":"","code":"MOTIF_DB"},{"path":"/reference/MOTIF_DB.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A MotifDB object with motifs from all bundled databases — MOTIF_DB","text":"MotifDB object","code":""},{"path":"/reference/MotifDB-class.html","id":null,"dir":"Reference","previous_headings":"","what":"MotifDB Class — MotifDB-class","title":"MotifDB Class — MotifDB-class","text":"S4 class store position weight matrices properties","code":""},{"path":"/reference/MotifDB-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"MotifDB Class — MotifDB-class","text":"mat numeric matrix containing position weight matrices log scale rc_mat numeric matrix containing reverse complement position weight matrices motif_lengths named integer vector containing length motif prior pssm prior probability spat_factors numeric matrix containing spatial factors spat_bin_size size spatial bins","code":""},{"path":"/reference/all_motif_datasets.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a data frame of all the motif datasets bundled with prego — all_motif_datasets","title":"Get a data frame of all the motif datasets bundled with prego — all_motif_datasets","text":"data frame contain PSSMs ('', 'C', 'G' 'T' columns), additional column 'motif' containing motif name. Individual datasets available within package HOMER_motifs, JASPAR_motifs, JOLMA_motifs, HOCOMOCO_motifs.","code":""},{"path":"/reference/all_motif_datasets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a data frame of all the motif datasets bundled with prego — all_motif_datasets","text":"","code":"all_motif_datasets()"},{"path":"/reference/all_motif_datasets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a data frame of all the motif datasets bundled with prego — all_motif_datasets","text":"data frame concatenates motifs \"HOMER\", \"JASPAR\" \"JOLMA\". Motif names prefixed dataset name, e.g. \"JASPAR.GATA4\".","code":""},{"path":"/reference/all_motif_datasets.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Get a data frame of all the motif datasets bundled with prego — all_motif_datasets","text":"HOMER: Heinz S, Benner C, Spann N, Bertolino E et al. Simple Combinations Lineage-Determining Transcription Factors Prime cis-Regulatory Elements Required Macrophage B Cell Identities. Mol Cell 2010 May 28;38(4):576-589. PMID: 20513432 JASPAR: Castro-Mondragon JA, Riudavets-Puig R, Rauluseviciute , Berhanu Lemma R, Turchi L, Blanc-Mathieu R, Lucas J, Boddie P, Khan , Manosalva Pérez N, Fornes O, Leung TY, Aguirre , Hammal F, Schmelter D, Baranasic D, Ballester B, Sandelin , Lenhard B, Vandepoele K, Wasserman WW, Parcy F, Mathelier JASPAR 2022: 9th release open-access database transcription factor binding profiles Nucleic Acids Res. 2022 Jan 7;50(D1):D165-D173.; doi: 10.1093/nar/gkab1113 JOLMA: Jolma, ., Yin, Y., Nitta, K. et al. DNA-dependent formation transcription factor pairs alters binding specificity. Nature 534, S15–S16 (2016). https://doi.org/10.1038/nature18912 HOCOMOCO: Ivan V. Kulakovskiy; Ilya E. Vorontsov; Ivan S. Yevshin; Ruslan N. Sharipov; Alla D. Fedorova; Eugene . Rumynskiy; Yulia . Medvedeva; Arturo Magana-Mora; Vladimir B. Bajic; Dmitry . Papatsenko; Fedor . Kolpakov; Vsevolod J. Makeev: HOCOMOCO: towards complete collection transcription factor binding models human mouse via large-scale ChIP-Seq analysis. Nucl. Acids Res., Database issue, gkx1106 (11 November 2017). https://doi.org/10.1093/nar/gkx1106","code":""},{"path":"/reference/all_motif_datasets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a data frame of all the motif datasets bundled with prego — all_motif_datasets","text":"","code":"all_motif_datasets() #> # A tibble: 49,269 x 8 #>        motif pos     A     C     G     T dataset motif_orig #> 1 HOMER.AP_1   0 0.419 0.275 0.277 0.028   HOMER       AP_1 #> 2 HOMER.AP_1   1 0.001 0.001 0.001 0.997   HOMER       AP_1 #> 3 HOMER.AP_1   2 0.010 0.002 0.965 0.023   HOMER       AP_1 #> 4 HOMER.AP_1   3 0.984 0.003 0.001 0.012   HOMER       AP_1 #> 5 HOMER.AP_1   4 0.062 0.579 0.305 0.054   HOMER       AP_1 #> 6 HOMER.AP_1   5 0.026 0.001 0.001 0.972   HOMER       AP_1 #> # ... with 49,263 more rows"},{"path":"/reference/as.data.frame-MotifDB-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a MotifDB object to a data frame — as.data.frame,MotifDB-method","title":"Convert a MotifDB object to a data frame — as.data.frame,MotifDB-method","text":"Convert MotifDB object data frame","code":""},{"path":"/reference/as.data.frame-MotifDB-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a MotifDB object to a data frame — as.data.frame,MotifDB-method","text":"","code":"# S4 method for class 'MotifDB' as.data.frame(x, row.names = NULL, optional = FALSE, ...)"},{"path":"/reference/as.data.frame-MotifDB-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a MotifDB object to a data frame — as.data.frame,MotifDB-method","text":"x MotifDB object row.names NULL character vector giving row names data frame optional logical. TRUE, setting row names converting column names (syntactic names: see make.names) optional ... additional arguments passed methods","code":""},{"path":"/reference/as.data.frame-MotifDB-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a MotifDB object to a data frame — as.data.frame,MotifDB-method","text":"data frame containing motif probabilities","code":""},{"path":"/reference/as.matrix-MotifDB-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a MotifDB object to a matrix — as.matrix,MotifDB-method","title":"Convert a MotifDB object to a matrix — as.matrix,MotifDB-method","text":"Convert MotifDB object matrix","code":""},{"path":"/reference/as.matrix-MotifDB-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a MotifDB object to a matrix — as.matrix,MotifDB-method","text":"","code":"# S4 method for class 'MotifDB' as.matrix(x, ...)"},{"path":"/reference/as.matrix-MotifDB-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a MotifDB object to a matrix — as.matrix,MotifDB-method","text":"x MotifDB object ... ignored arguments","code":""},{"path":"/reference/as.matrix-MotifDB-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a MotifDB object to a matrix — as.matrix,MotifDB-method","text":"matrix containing motif probabilities, rownames motif_position, colnames nucleotides","code":""},{"path":"/reference/bits_per_pos.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the number of bits per position in a Position-Specific Scoring Matrix (PSSM). — bits_per_pos","title":"Calculate the number of bits per position in a Position-Specific Scoring Matrix (PSSM). — bits_per_pos","text":"function takes PSSM input calculates number bits per position. PSSM data frame matrix columns representing nucleotides , C, G, T. function first normalizes PSSM dividing element sum row. , calculates entropy position using formula: bits = log2(4) + sum(p * log2(p)), p probability nucleotide position. Finally, sets negative values zero returns resulting bits per position.","code":""},{"path":"/reference/bits_per_pos.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the number of bits per position in a Position-Specific Scoring Matrix (PSSM). — bits_per_pos","text":"","code":"bits_per_pos(pssm, prior = 0.01)"},{"path":"/reference/bits_per_pos.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the number of bits per position in a Position-Specific Scoring Matrix (PSSM). — bits_per_pos","text":"pssm data frame matrix representing Position-Specific Scoring Matrix (PSSM). prior numeric value indicating prior probability nucleotide. Default 0.01.","code":""},{"path":"/reference/bits_per_pos.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the number of bits per position in a Position-Specific Scoring Matrix (PSSM). — bits_per_pos","text":"numeric vector representing number bits per position PSSM.","code":""},{"path":"/reference/bits_per_pos.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the number of bits per position in a Position-Specific Scoring Matrix (PSSM). — bits_per_pos","text":"","code":"pssm <- data.frame(     A = c(0.2, 0.3, 0.1, 0.4),     C = c(0.1, 0.2, 0.3, 0.4),     G = c(0.4, 0.3, 0.2, 0.1),     T = c(0.3, 0.2, 0.4, 0.1) ) bits_per_pos(pssm) #> [1] 0.14121539 0.02684396 0.14121539 0.25558682"},{"path":"/reference/calc_seq_pwm.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Position Weight Matrix (PWM) Scores for DNA Sequences — calc_seq_pwm","title":"Calculate Position Weight Matrix (PWM) Scores for DNA Sequences — calc_seq_pwm","text":"Calculate Position Weight Matrix (PWM) Scores DNA Sequences","code":""},{"path":"/reference/calc_seq_pwm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Position Weight Matrix (PWM) Scores for DNA Sequences — calc_seq_pwm","text":"","code":"calc_seq_pwm(sequences, mdb, bidirect = TRUE)"},{"path":"/reference/calc_seq_pwm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Position Weight Matrix (PWM) Scores for DNA Sequences — calc_seq_pwm","text":"sequences Character vector DNA sequences. mdb MotifDB object containing PWMs. bidirect motif bi-directional. TRUE, reverse-complement motif used well.","code":""},{"path":"/reference/calc_seq_pwm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Position Weight Matrix (PWM) Scores for DNA Sequences — calc_seq_pwm","text":"numeric matrix sequences rows motifs columns, containing PWM scores. Row names preserved input sequences exist. Column names preserved PWM matrix exist.","code":""},{"path":"/reference/calc_seq_pwm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Position Weight Matrix (PWM) Scores for DNA Sequences — calc_seq_pwm","text":"","code":"sequences <- c(\"ACGTACGT\", \"TGCATGCA\") scores <- calc_seq_pwm(sequences, MOTIF_DB) #> Error in calc_seq_pwm(sequences, MOTIF_DB): could not find function \"calc_seq_pwm\""},{"path":"/reference/calc_sequences_dinuc_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Dinucleotide Distribution in Sequences — calc_sequences_dinuc_dist","title":"Calculate Dinucleotide Distribution in Sequences — calc_sequences_dinuc_dist","text":"Calculate Dinucleotide Distribution Sequences","code":""},{"path":"/reference/calc_sequences_dinuc_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Dinucleotide Distribution in Sequences — calc_sequences_dinuc_dist","text":"","code":"calc_sequences_dinuc_dist(sequences, size = NULL)"},{"path":"/reference/calc_sequences_dinuc_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Dinucleotide Distribution in Sequences — calc_sequences_dinuc_dist","text":"sequences character vector containing sequences analyze. element vector single sequence. size integer specifying size consider analysis. NULL (default), maximum length sequences sequences vector used.","code":""},{"path":"/reference/calc_sequences_dinuc_dist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Dinucleotide Distribution in Sequences — calc_sequences_dinuc_dist","text":"data frame columns 'pos' 16 columns representing possible dinucleotide. row represents position sequences (1 size), contains fraction dinucleotide position across sequences.","code":""},{"path":"/reference/calc_sequences_dinuc_dist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Dinucleotide Distribution in Sequences — calc_sequences_dinuc_dist","text":"","code":"# Generate some random sequences for testing set.seed(60427) sequences <- sapply(1:100, function(x) {     paste0(sample(c(\"A\", \"C\", \"G\", \"T\"), 1000, replace = TRUE), collapse = \"\") }) sequences <- as.character(sequences)  # Calculate the dinucleotide distribution result <- calc_sequences_dinuc_dist(sequences)  head(result) #>   pos   AA   AC   AG   AT   CA   CC   CG   CT   GA   GC   GG   GT   TA   TC #> 1   1 0.10 0.06 0.04 0.10 0.07 0.06 0.08 0.07 0.03 0.03 0.06 0.07 0.07 0.04 #> 2   2 0.07 0.06 0.10 0.04 0.02 0.08 0.07 0.02 0.09 0.08 0.04 0.05 0.10 0.06 #> 3   3 0.05 0.09 0.05 0.09 0.09 0.09 0.04 0.06 0.05 0.06 0.10 0.09 0.02 0.04 #> 4   4 0.03 0.06 0.06 0.06 0.07 0.10 0.05 0.06 0.06 0.05 0.05 0.07 0.05 0.09 #> 5   5 0.11 0.04 0.03 0.03 0.04 0.09 0.08 0.09 0.06 0.01 0.10 0.05 0.06 0.09 #> 6   6 0.06 0.08 0.06 0.07 0.03 0.07 0.05 0.08 0.04 0.08 0.09 0.05 0.08 0.01 #>     TG   TT #> 1 0.08 0.04 #> 2 0.09 0.03 #> 3 0.04 0.04 #> 4 0.06 0.08 #> 5 0.05 0.07 #> 6 0.11 0.04"},{"path":"/reference/calc_sequences_dinucs.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Dinucleotide Counts for Sequences — calc_sequences_dinucs","title":"Calculate Dinucleotide Counts for Sequences — calc_sequences_dinucs","text":"function calculates total count dinucleotide sequence vector DNA sequences.","code":""},{"path":"/reference/calc_sequences_dinucs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Dinucleotide Counts for Sequences — calc_sequences_dinucs","text":"","code":"calc_sequences_dinucs(sequences)"},{"path":"/reference/calc_sequences_dinucs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Dinucleotide Counts for Sequences — calc_sequences_dinucs","text":"sequences character vector DNA sequences. element string representing DNA sequence composed , T, C, G.","code":""},{"path":"/reference/calc_sequences_dinucs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Dinucleotide Counts for Sequences — calc_sequences_dinucs","text":"numeric matrix : row corresponds sequence input vector. column represents specific dinucleotide (AA, AC, AG, , CA, CC, etc.). values matrix counts dinucleotide sequence. Column names set corresponding dinucleotides.","code":""},{"path":"/reference/calc_sequences_dinucs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Dinucleotide Counts for Sequences — calc_sequences_dinucs","text":"","code":"sequences <- c(\"ATCG\", \"GCTA\", \"AATT\") result <- calc_sequences_dinucs(sequences) print(result) #>      AA AC AG AT CA CC CG CT GA GC GG GT TA TC TG TT #> [1,]  0  0  0  1  0  0  1  0  0  0  0  0  0  1  0  0 #> [2,]  0  0  0  0  0  0  0  1  0  1  0  0  1  0  0  0 #> [3,]  1  0  0  1  0  0  0  0  0  0  0  0  0  0  0  1"},{"path":"/reference/calc_sequences_trinuc_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Trinucleotide Distribution in Sequences — calc_sequences_trinuc_dist","title":"Calculate Trinucleotide Distribution in Sequences — calc_sequences_trinuc_dist","text":"Calculate Trinucleotide Distribution Sequences","code":""},{"path":"/reference/calc_sequences_trinuc_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Trinucleotide Distribution in Sequences — calc_sequences_trinuc_dist","text":"","code":"calc_sequences_trinuc_dist(sequences, size = NULL)"},{"path":"/reference/calc_sequences_trinuc_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Trinucleotide Distribution in Sequences — calc_sequences_trinuc_dist","text":"sequences character vector containing sequences analyze. element vector single sequence. size integer specifying size consider analysis. NULL (default), maximum length sequences sequences vector used.","code":""},{"path":"/reference/calc_sequences_trinuc_dist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Trinucleotide Distribution in Sequences — calc_sequences_trinuc_dist","text":"data frame columns 'pos' 64 columns representing possible trinucleotide. row represents position sequences (1 size), contains fraction trinucleotide position across sequences.","code":""},{"path":"/reference/calc_sequences_trinuc_dist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Trinucleotide Distribution in Sequences — calc_sequences_trinuc_dist","text":"","code":"# Generate some random sequences for testing set.seed(60427) sequences <- sapply(1:100, function(x) {     paste0(sample(c(\"A\", \"C\", \"G\", \"T\"), 1000, replace = TRUE), collapse = \"\") }) sequences <- as.character(sequences)  # Calculate the trinucleotide distribution result <- calc_sequences_trinuc_dist(sequences)  head(result) #>   pos  AAA  AAC  AAG  AAT  ACA  ACC  ACG  ACT  AGA  AGC  AGG  AGT  ATA  ATC #> 1   1 0.02 0.02 0.04 0.02 0.01 0.04 0.01 0.00 0.02 0.02 0.00 0.00 0.03 0.04 #> 2   2 0.01 0.01 0.02 0.03 0.03 0.01 0.01 0.01 0.01 0.01 0.04 0.04 0.01 0.00 #> 3   3 0.00 0.01 0.01 0.03 0.02 0.04 0.01 0.02 0.02 0.01 0.01 0.01 0.03 0.01 #> 4   4 0.02 0.00 0.00 0.01 0.00 0.03 0.01 0.02 0.01 0.00 0.04 0.01 0.01 0.02 #> 5   5 0.02 0.03 0.04 0.02 0.00 0.01 0.02 0.01 0.01 0.01 0.01 0.00 0.02 0.00 #> 6   6 0.00 0.02 0.01 0.03 0.00 0.05 0.02 0.01 0.02 0.01 0.02 0.01 0.01 0.02 #>    ATG  ATT  CAA  CAC  CAG  CAT  CCA  CCC  CCG  CCT  CGA  CGC  CGG  CGT  CTA #> 1 0.02 0.01 0.02 0.01 0.03 0.01 0.00 0.02 0.03 0.01 0.01 0.04 0.00 0.03 0.01 #> 2 0.02 0.01 0.02 0.00 0.00 0.00 0.02 0.02 0.03 0.01 0.01 0.02 0.02 0.02 0.00 #> 3 0.03 0.02 0.01 0.03 0.04 0.01 0.01 0.03 0.03 0.02 0.01 0.01 0.01 0.01 0.01 #> 4 0.02 0.01 0.04 0.01 0.01 0.01 0.01 0.02 0.05 0.02 0.00 0.00 0.02 0.03 0.01 #> 5 0.01 0.00 0.01 0.01 0.02 0.00 0.01 0.02 0.02 0.04 0.00 0.03 0.03 0.02 0.03 #> 6 0.04 0.00 0.00 0.00 0.01 0.02 0.01 0.02 0.02 0.02 0.01 0.02 0.01 0.01 0.03 #>    CTC  CTG  CTT  GAA  GAC  GAG  GAT  GCA  GCC  GCG  GCT  GGA  GGC  GGG  GGT #> 1 0.01 0.03 0.02 0.00 0.02 0.01 0.00 0.00 0.00 0.02 0.01 0.02 0.01 0.03 0.00 #> 2 0.02 0.00 0.00 0.02 0.06 0.00 0.01 0.02 0.03 0.00 0.03 0.02 0.00 0.01 0.01 #> 3 0.01 0.02 0.02 0.02 0.01 0.00 0.02 0.03 0.02 0.00 0.01 0.02 0.02 0.03 0.03 #> 4 0.03 0.01 0.01 0.01 0.03 0.02 0.00 0.02 0.02 0.00 0.01 0.03 0.00 0.01 0.01 #> 5 0.00 0.06 0.00 0.02 0.01 0.00 0.03 0.00 0.01 0.00 0.00 0.02 0.03 0.03 0.02 #> 6 0.02 0.00 0.03 0.02 0.01 0.00 0.01 0.01 0.03 0.02 0.02 0.04 0.00 0.03 0.02 #>    GTA  GTC  GTG  GTT  TAA  TAC  TAG  TAT  TCA  TCC  TCG  TCT  TGA  TGC  TGG #> 1 0.04 0.00 0.03 0.00 0.03 0.01 0.02 0.01 0.01 0.02 0.01 0.00 0.04 0.01 0.01 #> 2 0.01 0.01 0.01 0.02 0.00 0.02 0.03 0.05 0.02 0.03 0.00 0.01 0.01 0.03 0.03 #> 3 0.01 0.05 0.01 0.02 0.00 0.01 0.01 0.00 0.01 0.01 0.01 0.01 0.01 0.01 0.00 #> 4 0.02 0.00 0.01 0.04 0.04 0.00 0.00 0.01 0.01 0.02 0.02 0.04 0.02 0.01 0.03 #> 5 0.03 0.01 0.01 0.00 0.01 0.03 0.00 0.02 0.02 0.03 0.01 0.03 0.01 0.01 0.02 #> 6 0.00 0.02 0.02 0.01 0.00 0.02 0.04 0.02 0.00 0.01 0.00 0.00 0.02 0.04 0.05 #>    TGT  TTA  TTC  TTG  TTT #> 1 0.02 0.02 0.01 0.01 0.00 #> 2 0.02 0.00 0.01 0.01 0.01 #> 3 0.02 0.00 0.02 0.00 0.02 #> 4 0.00 0.02 0.04 0.01 0.01 #> 5 0.01 0.00 0.00 0.03 0.04 #> 6 0.00 0.01 0.02 0.00 0.01"},{"path":"/reference/cluster_mat_example.html","id":null,"dir":"Reference","previous_headings":"","what":"Dataset examples — cluster_mat_example","title":"Dataset examples — cluster_mat_example","text":"Dataset examples","code":""},{"path":"/reference/cluster_mat_example.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dataset examples — cluster_mat_example","text":"","code":"cluster_mat_example  cluster_sequences_example  clusters_example  response_mat_example  sequences_example"},{"path":"/reference/cluster_mat_example.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Dataset examples — cluster_mat_example","text":"sequences response variables various formats function examples object class character length 2359. object class character length 2359. object class matrix (inherits array) 1000 rows 5 columns. object class character length 1000.","code":""},{"path":"/reference/compute_local_pwm.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute local PWMs for a set of sequences given a PSSM matrix — compute_local_pwm","title":"Compute local PWMs for a set of sequences given a PSSM matrix — compute_local_pwm","text":"compute local PWM position every sequence. edges sequences become NA.","code":""},{"path":"/reference/compute_local_pwm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute local PWMs for a set of sequences given a PSSM matrix — compute_local_pwm","text":"","code":"compute_local_pwm(   sequences,   pssm,   spat = NULL,   spat_min = 0,   spat_max = NULL,   bidirect = TRUE,   prior = 0.01 )"},{"path":"/reference/compute_local_pwm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute local PWMs for a set of sequences given a PSSM matrix — compute_local_pwm","text":"sequences vector sequences pssm PSSM matrix data frame. columns matrix data frame named nucleotides ('', 'C', 'G' 'T'). spat data frame spatial model (returned $spat slot regression). contain column called 'bin' column called 'spat_factor'. spat_min minimum position use sequences. default 1. spat_max maximum position use sequences. default length sequences. bidirect motif bi-directional. TRUE, reverse-complement motif used well. prior prior probability nucleotide.","code":""},{"path":"/reference/compute_local_pwm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute local PWMs for a set of sequences given a PSSM matrix — compute_local_pwm","text":"matrix length(sequences) rows ncol(pssm) columns local PWM sequence position.","code":""},{"path":"/reference/compute_local_pwm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute local PWMs for a set of sequences given a PSSM matrix — compute_local_pwm","text":"","code":"if (FALSE) { # \\dontrun{ res <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1])  pwm <- compute_local_pwm(cluster_sequences_example, res$pssm, res$spat) head(pwm) } # }"},{"path":"/reference/compute_pwm.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute PWMs for a set of sequences given a PSSM matrix — compute_pwm","title":"Compute PWMs for a set of sequences given a PSSM matrix — compute_pwm","text":"Compute PWMs set sequences given PSSM matrix","code":""},{"path":"/reference/compute_pwm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute PWMs for a set of sequences given a PSSM matrix — compute_pwm","text":"","code":"compute_pwm(   sequences,   pssm,   spat = NULL,   spat_min = 1,   spat_max = NULL,   bidirect = TRUE,   prior = 0.01,   func = \"logSumExp\" )"},{"path":"/reference/compute_pwm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute PWMs for a set of sequences given a PSSM matrix — compute_pwm","text":"sequences vector sequences pssm PSSM matrix data frame. columns matrix data frame named nucleotides ('', 'C', 'G' 'T'). spat data frame spatial model (returned $spat slot regression). contain column called 'bin' column called 'spat_factor'. spat_min minimum position use sequences. default 1. spat_max maximum position use sequences. default length sequences. bidirect motif bi-directional. TRUE, reverse-complement motif used well. prior prior probability nucleotide. func function use combine PWMs sequence. Either 'logSumExp' 'max'. default 'logSumExp'.","code":""},{"path":"/reference/compute_pwm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute PWMs for a set of sequences given a PSSM matrix — compute_pwm","text":"vector predicted pwm sequence.","code":""},{"path":"/reference/compute_pwm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute PWMs for a set of sequences given a PSSM matrix — compute_pwm","text":"","code":"if (FALSE) { # \\dontrun{ res <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1])  pwm <- compute_pwm(cluster_sequences_example, res$pssm, res$spat) head(pwm)  # this is similar to the prediction in the regression head(res$pred) } # }"},{"path":"/reference/consensus_from_pssm.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert PSSM to consensus sequence — consensus_from_pssm","title":"Convert PSSM to consensus sequence — consensus_from_pssm","text":"Convert PSSM consensus sequence","code":""},{"path":"/reference/consensus_from_pssm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert PSSM to consensus sequence — consensus_from_pssm","text":"","code":"consensus_from_pssm(pssm, single_thresh = 0.4, double_thresh = 0.6)"},{"path":"/reference/consensus_from_pssm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert PSSM to consensus sequence — consensus_from_pssm","text":"pssm PSSM matrix single_thresh, double_thresh thresholds consensus sequence calculation (single double nucleotides)","code":""},{"path":"/reference/consensus_from_pssm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert PSSM to consensus sequence — consensus_from_pssm","text":"consensus sequence PSSM. consensus sequence can found, function returns NA.","code":""},{"path":"/reference/consensus_from_pssm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert PSSM to consensus sequence — consensus_from_pssm","text":"","code":"if (FALSE) { # \\dontrun{ res <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1]) consensus_from_pssm(res$pssm) } # }"},{"path":"/reference/create_motif_db.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a MotifDB object from a tidy data frame — create_motif_db","title":"Create a MotifDB object from a tidy data frame — create_motif_db","text":"Create MotifDB object tidy data frame","code":""},{"path":"/reference/create_motif_db.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a MotifDB object from a tidy data frame — create_motif_db","text":"","code":"create_motif_db(motif_db, prior = 0.01, spat_factors = NULL, spat_bin_size = 1)"},{"path":"/reference/create_motif_db.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a MotifDB object from a tidy data frame — create_motif_db","text":"motif_db tidy data frame containing motif information prior Pseudocount prior add probabilities (default: 0.01) spat_factors Matrix spatial factors (rows=motifs, cols=bins) NULL spat_bin_size Size spatial bins (default: 1)","code":""},{"path":"/reference/create_motif_db.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a MotifDB object from a tidy data frame — create_motif_db","text":"MotifDB object","code":""},{"path":"/reference/export_multi_regression.html","id":null,"dir":"Reference","previous_headings":"","what":"Export a multiple motif regression model — export_multi_regression","title":"Export a multiple motif regression model — export_multi_regression","text":"Export multiple motif regression model","code":""},{"path":"/reference/export_multi_regression.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Export a multiple motif regression model — export_multi_regression","text":"","code":"export_multi_regression(reg, fn = NULL)"},{"path":"/reference/export_multi_regression.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Export a multiple motif regression model — export_multi_regression","text":"reg multiple motif regression model, returned regress_pwm motif_num > 1 fn file name save model . NULL - model returned list","code":""},{"path":"/reference/export_multi_regression.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Export a multiple motif regression model — export_multi_regression","text":"None","code":""},{"path":"/reference/export_multi_regression.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Export a multiple motif regression model — export_multi_regression","text":"","code":"if (FALSE) { # \\dontrun{ res_multi <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1],     final_metric = \"ks\", spat_bin_size = 40,     spat_num_bins = 7,     motif_num = 2 ) export_fn <- tempfile() export_multi_regression(res_multi, export_fn)  light_res <- export_multi_regression(res_multi)  # loading can be done by: r <- load_multi_regression(export_fn) } # }"},{"path":"/reference/export_regression_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Export a motif regression model — export_regression_model","title":"Export a motif regression model — export_regression_model","text":"Export motif regression model","code":""},{"path":"/reference/export_regression_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Export a motif regression model — export_regression_model","text":"","code":"export_regression_model(model, fn = NULL)"},{"path":"/reference/export_regression_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Export a motif regression model — export_regression_model","text":"model motif regression model, returned regress_pwm motif_num = 1 fn file name save model . NULL - model returned list","code":""},{"path":"/reference/export_regression_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Export a motif regression model — export_regression_model","text":"None","code":""},{"path":"/reference/export_regression_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Export a motif regression model — export_regression_model","text":"","code":"if (FALSE) { # \\dontrun{ res <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1],     final_metric = \"ks\", spat_bin_size = 40,     spat_num_bins = 7 ) export_fn <- tempfile() export_regression_model(export_fn) r <- load_regression(export_fn) } # }"},{"path":"/reference/extract_pwm.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract pwm of sequences from a motif database — extract_pwm_old","title":"Extract pwm of sequences from a motif database — extract_pwm_old","text":"Extracts pwm motif motif database. extract_pwm_old deprecated version function, slower, returns slightly different results due float percision instead double. sequences length, old version used.","code":""},{"path":"/reference/extract_pwm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract pwm of sequences from a motif database — extract_pwm_old","text":"","code":"extract_pwm_old(   sequences,   motifs = NULL,   dataset = all_motif_datasets(),   spat = NULL,   spat_min = 0,   spat_max = NULL,   bidirect = TRUE,   prior = 0.01,   func = \"logSumExp\",   parallel = getOption(\"prego.parallel\", TRUE) )  extract_pwm(   sequences,   motifs = NULL,   dataset = MOTIF_DB,   spat = NULL,   spat_min = 0,   spat_max = NULL,   bidirect = TRUE,   prior = 0.01,   func = \"logSumExp\",   parallel = getOption(\"prego.parallel\", TRUE) )"},{"path":"/reference/extract_pwm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract pwm of sequences from a motif database — extract_pwm_old","text":"sequences vector sequences motifs names specific motifs extract dataset dataset data frame PSSMs ('', 'C', 'G' 'T' columns), additional column 'motif' containing motif name, example HOMER_motifs JASPAR_motifs, all_motif_datasets(), MotifDB object. spat data frame spatial model (returned $spat slot regression). contain column called 'bin' column called 'spat_factor'. spat_min minimum position use sequences. default 1. spat_max maximum position use sequences. default length sequences. bidirect motif bi-directional. TRUE, reverse-complement motif used well. prior prior probability nucleotide. func function use combine PWMs sequence. Either 'logSumExp' 'max'. default 'logSumExp'. parallel logical, whether use parallel processing","code":""},{"path":"/reference/extract_pwm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract pwm of sequences from a motif database — extract_pwm_old","text":"matrix size # sequences x # motifs pwm sequence motif","code":""},{"path":"/reference/extract_pwm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract pwm of sequences from a motif database — extract_pwm_old","text":"","code":"if (FALSE) { # \\dontrun{ pwms <- extract_pwm(     cluster_sequences_example,     motifs = c(\"JASPAR.CDX1\", \"HOMER.Hnf1\", \"HOMER.GATA3_2\") ) head(pwms)  # all motifs all_pwms <- extract_pwm(cluster_sequences_example, prior = 0.01) dim(all_pwms) all_pwms[1:5, 1:5]  # for a specific dataset pwms_jaspar <- extract_pwm(cluster_sequences_example, dataset = JASPAR_motifs, prior = 0.01) head(pwms_jaspar)  # for specific motifs pwms_jaspar <- extract_pwm(     cluster_sequences_example,     motifs = c(\"JASPAR.CDX1\", \"JASPAR.CDX2\"),     prior = 0.01 ) } # }"},{"path":"/reference/generate_kmers.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate kmers — generate_kmers","title":"Generate kmers — generate_kmers","text":"function generates possible kmers considering gap length. Gaps represented 'N'.","code":""},{"path":"/reference/generate_kmers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate kmers — generate_kmers","text":"","code":"generate_kmers(kmer_length, max_gap = 0, min_gap = 0)"},{"path":"/reference/generate_kmers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate kmers — generate_kmers","text":"kmer_length number non-gap characters motifs screened. max_gap maximum length gap considered pattern. Default: 0 min_gap minimum length gap considered pattern. Default: 0","code":""},{"path":"/reference/generate_kmers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate kmers — generate_kmers","text":"vector possible kmers considering gap length.","code":""},{"path":"/reference/generate_kmers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate kmers — generate_kmers","text":"","code":"# Generate kmers of length 2 without any gaps generate_kmers(2) #>  [1] \"TT\" \"CT\" \"GT\" \"AT\" \"TC\" \"CC\" \"GC\" \"AC\" \"TG\" \"CG\" \"GG\" \"AG\" \"TA\" \"CA\" \"GA\" #> [16] \"AA\"  # Generate kmers of length 3 with a single gap (1 'N') at any position generate_kmers(3, min_gap = 1, max_gap = 1) #>   [1] \"NTT\" \"NTT\" \"NTT\" \"NTT\" \"NCT\" \"NCT\" \"NCT\" \"NCT\" \"NGT\" \"NGT\" \"NGT\" \"NGT\" #>  [13] \"NAT\" \"NAT\" \"NAT\" \"NAT\" \"NTC\" \"NTC\" \"NTC\" \"NTC\" \"NCC\" \"NCC\" \"NCC\" \"NCC\" #>  [25] \"NGC\" \"NGC\" \"NGC\" \"NGC\" \"NAC\" \"NAC\" \"NAC\" \"NAC\" \"NTG\" \"NTG\" \"NTG\" \"NTG\" #>  [37] \"NCG\" \"NCG\" \"NCG\" \"NCG\" \"NGG\" \"NGG\" \"NGG\" \"NGG\" \"NAG\" \"NAG\" \"NAG\" \"NAG\" #>  [49] \"NTA\" \"NTA\" \"NTA\" \"NTA\" \"NCA\" \"NCA\" \"NCA\" \"NCA\" \"NGA\" \"NGA\" \"NGA\" \"NGA\" #>  [61] \"NAA\" \"NAA\" \"NAA\" \"NAA\" \"TNT\" \"CNT\" \"GNT\" \"ANT\" \"TNT\" \"CNT\" \"GNT\" \"ANT\" #>  [73] \"TNT\" \"CNT\" \"GNT\" \"ANT\" \"TNT\" \"CNT\" \"GNT\" \"ANT\" \"TNC\" \"CNC\" \"GNC\" \"ANC\" #>  [85] \"TNC\" \"CNC\" \"GNC\" \"ANC\" \"TNC\" \"CNC\" \"GNC\" \"ANC\" \"TNC\" \"CNC\" \"GNC\" \"ANC\" #>  [97] \"TNG\" \"CNG\" \"GNG\" \"ANG\" \"TNG\" \"CNG\" \"GNG\" \"ANG\" \"TNG\" \"CNG\" \"GNG\" \"ANG\" #> [109] \"TNG\" \"CNG\" \"GNG\" \"ANG\" \"TNA\" \"CNA\" \"GNA\" \"ANA\" \"TNA\" \"CNA\" \"GNA\" \"ANA\" #> [121] \"TNA\" \"CNA\" \"GNA\" \"ANA\" \"TNA\" \"CNA\" \"GNA\" \"ANA\" \"TTN\" \"CTN\" \"GTN\" \"ATN\" #> [133] \"TCN\" \"CCN\" \"GCN\" \"ACN\" \"TGN\" \"CGN\" \"GGN\" \"AGN\" \"TAN\" \"CAN\" \"GAN\" \"AAN\" #> [145] \"TTN\" \"CTN\" \"GTN\" \"ATN\" \"TCN\" \"CCN\" \"GCN\" \"ACN\" \"TGN\" \"CGN\" \"GGN\" \"AGN\" #> [157] \"TAN\" \"CAN\" \"GAN\" \"AAN\" \"TTN\" \"CTN\" \"GTN\" \"ATN\" \"TCN\" \"CCN\" \"GCN\" \"ACN\" #> [169] \"TGN\" \"CGN\" \"GGN\" \"AGN\" \"TAN\" \"CAN\" \"GAN\" \"AAN\" \"TTN\" \"CTN\" \"GTN\" \"ATN\" #> [181] \"TCN\" \"CCN\" \"GCN\" \"ACN\" \"TGN\" \"CGN\" \"GGN\" \"AGN\" \"TAN\" \"CAN\" \"GAN\" \"AAN\"  # Generate kmers of length 3 with a gap of 1 to 2 'N's at any position generate_kmers(3, min_gap = 1, max_gap = 2) #>   [1] \"NTT\" \"NTT\" \"NTT\" \"NTT\" \"NCT\" \"NCT\" \"NCT\" \"NCT\" \"NGT\" \"NGT\" \"NGT\" \"NGT\" #>  [13] \"NAT\" \"NAT\" \"NAT\" \"NAT\" \"NTC\" \"NTC\" \"NTC\" \"NTC\" \"NCC\" \"NCC\" \"NCC\" \"NCC\" #>  [25] \"NGC\" \"NGC\" \"NGC\" \"NGC\" \"NAC\" \"NAC\" \"NAC\" \"NAC\" \"NTG\" \"NTG\" \"NTG\" \"NTG\" #>  [37] \"NCG\" \"NCG\" \"NCG\" \"NCG\" \"NGG\" \"NGG\" \"NGG\" \"NGG\" \"NAG\" \"NAG\" \"NAG\" \"NAG\" #>  [49] \"NTA\" \"NTA\" \"NTA\" \"NTA\" \"NCA\" \"NCA\" \"NCA\" \"NCA\" \"NGA\" \"NGA\" \"NGA\" \"NGA\" #>  [61] \"NAA\" \"NAA\" \"NAA\" \"NAA\" \"TNT\" \"CNT\" \"GNT\" \"ANT\" \"TNT\" \"CNT\" \"GNT\" \"ANT\" #>  [73] \"TNT\" \"CNT\" \"GNT\" \"ANT\" \"TNT\" \"CNT\" \"GNT\" \"ANT\" \"TNC\" \"CNC\" \"GNC\" \"ANC\" #>  [85] \"TNC\" \"CNC\" \"GNC\" \"ANC\" \"TNC\" \"CNC\" \"GNC\" \"ANC\" \"TNC\" \"CNC\" \"GNC\" \"ANC\" #>  [97] \"TNG\" \"CNG\" \"GNG\" \"ANG\" \"TNG\" \"CNG\" \"GNG\" \"ANG\" \"TNG\" \"CNG\" \"GNG\" \"ANG\" #> [109] \"TNG\" \"CNG\" \"GNG\" \"ANG\" \"TNA\" \"CNA\" \"GNA\" \"ANA\" \"TNA\" \"CNA\" \"GNA\" \"ANA\" #> [121] \"TNA\" \"CNA\" \"GNA\" \"ANA\" \"TNA\" \"CNA\" \"GNA\" \"ANA\" \"TTN\" \"CTN\" \"GTN\" \"ATN\" #> [133] \"TCN\" \"CCN\" \"GCN\" \"ACN\" \"TGN\" \"CGN\" \"GGN\" \"AGN\" \"TAN\" \"CAN\" \"GAN\" \"AAN\" #> [145] \"TTN\" \"CTN\" \"GTN\" \"ATN\" \"TCN\" \"CCN\" \"GCN\" \"ACN\" \"TGN\" \"CGN\" \"GGN\" \"AGN\" #> [157] \"TAN\" \"CAN\" \"GAN\" \"AAN\" \"TTN\" \"CTN\" \"GTN\" \"ATN\" \"TCN\" \"CCN\" \"GCN\" \"ACN\" #> [169] \"TGN\" \"CGN\" \"GGN\" \"AGN\" \"TAN\" \"CAN\" \"GAN\" \"AAN\" \"TTN\" \"CTN\" \"GTN\" \"ATN\" #> [181] \"TCN\" \"CCN\" \"GCN\" \"ACN\" \"TGN\" \"CGN\" \"GGN\" \"AGN\" \"TAN\" \"CAN\" \"GAN\" \"AAN\" #> [193] \"NNT\" \"NNT\" \"NNT\" \"NNT\" \"NNT\" \"NNT\" \"NNT\" \"NNT\" \"NNT\" \"NNT\" \"NNT\" \"NNT\" #> [205] \"NNT\" \"NNT\" \"NNT\" \"NNT\" \"NNC\" \"NNC\" \"NNC\" \"NNC\" \"NNC\" \"NNC\" \"NNC\" \"NNC\" #> [217] \"NNC\" \"NNC\" \"NNC\" \"NNC\" \"NNC\" \"NNC\" \"NNC\" \"NNC\" \"NNG\" \"NNG\" \"NNG\" \"NNG\" #> [229] \"NNG\" \"NNG\" \"NNG\" \"NNG\" \"NNG\" \"NNG\" \"NNG\" \"NNG\" \"NNG\" \"NNG\" \"NNG\" \"NNG\" #> [241] \"NNA\" \"NNA\" \"NNA\" \"NNA\" \"NNA\" \"NNA\" \"NNA\" \"NNA\" \"NNA\" \"NNA\" \"NNA\" \"NNA\" #> [253] \"NNA\" \"NNA\" \"NNA\" \"NNA\" \"TNN\" \"CNN\" \"GNN\" \"ANN\" \"TNN\" \"CNN\" \"GNN\" \"ANN\" #> [265] \"TNN\" \"CNN\" \"GNN\" \"ANN\" \"TNN\" \"CNN\" \"GNN\" \"ANN\" \"TNN\" \"CNN\" \"GNN\" \"ANN\" #> [277] \"TNN\" \"CNN\" \"GNN\" \"ANN\" \"TNN\" \"CNN\" \"GNN\" \"ANN\" \"TNN\" \"CNN\" \"GNN\" \"ANN\" #> [289] \"TNN\" \"CNN\" \"GNN\" \"ANN\" \"TNN\" \"CNN\" \"GNN\" \"ANN\" \"TNN\" \"CNN\" \"GNN\" \"ANN\" #> [301] \"TNN\" \"CNN\" \"GNN\" \"ANN\" \"TNN\" \"CNN\" \"GNN\" \"ANN\" \"TNN\" \"CNN\" \"GNN\" \"ANN\" #> [313] \"TNN\" \"CNN\" \"GNN\" \"ANN\" \"TNN\" \"CNN\" \"GNN\" \"ANN\"  # Generate kmers of length 3 with a gap of 2 'N's at any position generate_kmers(3, min_gap = 2, max_gap = 2) #>   [1] \"NNT\" \"NNT\" \"NNT\" \"NNT\" \"NNT\" \"NNT\" \"NNT\" \"NNT\" \"NNT\" \"NNT\" \"NNT\" \"NNT\" #>  [13] \"NNT\" \"NNT\" \"NNT\" \"NNT\" \"NNC\" \"NNC\" \"NNC\" \"NNC\" \"NNC\" \"NNC\" \"NNC\" \"NNC\" #>  [25] \"NNC\" \"NNC\" \"NNC\" \"NNC\" \"NNC\" \"NNC\" \"NNC\" \"NNC\" \"NNG\" \"NNG\" \"NNG\" \"NNG\" #>  [37] \"NNG\" \"NNG\" \"NNG\" \"NNG\" \"NNG\" \"NNG\" \"NNG\" \"NNG\" \"NNG\" \"NNG\" \"NNG\" \"NNG\" #>  [49] \"NNA\" \"NNA\" \"NNA\" \"NNA\" \"NNA\" \"NNA\" \"NNA\" \"NNA\" \"NNA\" \"NNA\" \"NNA\" \"NNA\" #>  [61] \"NNA\" \"NNA\" \"NNA\" \"NNA\" \"TNN\" \"CNN\" \"GNN\" \"ANN\" \"TNN\" \"CNN\" \"GNN\" \"ANN\" #>  [73] \"TNN\" \"CNN\" \"GNN\" \"ANN\" \"TNN\" \"CNN\" \"GNN\" \"ANN\" \"TNN\" \"CNN\" \"GNN\" \"ANN\" #>  [85] \"TNN\" \"CNN\" \"GNN\" \"ANN\" \"TNN\" \"CNN\" \"GNN\" \"ANN\" \"TNN\" \"CNN\" \"GNN\" \"ANN\" #>  [97] \"TNN\" \"CNN\" \"GNN\" \"ANN\" \"TNN\" \"CNN\" \"GNN\" \"ANN\" \"TNN\" \"CNN\" \"GNN\" \"ANN\" #> [109] \"TNN\" \"CNN\" \"GNN\" \"ANN\" \"TNN\" \"CNN\" \"GNN\" \"ANN\" \"TNN\" \"CNN\" \"GNN\" \"ANN\" #> [121] \"TNN\" \"CNN\" \"GNN\" \"ANN\" \"TNN\" \"CNN\" \"GNN\" \"ANN\""},{"path":"/reference/get_motif_pssm.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract pssm of sequences from a motif database — get_motif_pssm","title":"Extract pssm of sequences from a motif database — get_motif_pssm","text":"Extract pssm sequences motif database","code":""},{"path":"/reference/get_motif_pssm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract pssm of sequences from a motif database — get_motif_pssm","text":"","code":"get_motif_pssm(motif, dataset = all_motif_datasets())"},{"path":"/reference/get_motif_pssm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract pssm of sequences from a motif database — get_motif_pssm","text":"motif name motif extract dataset dataset data frame PSSMs ('', 'C', 'G' 'T' columns), additional column 'motif' containing motif name, example HOMER_motifs JASPAR_motifs, all_motif_datasets().","code":""},{"path":"/reference/get_motif_pssm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract pssm of sequences from a motif database — get_motif_pssm","text":"data frame pssm motif","code":""},{"path":"/reference/get_motif_pssm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract pssm of sequences from a motif database — get_motif_pssm","text":"","code":"get_motif_pssm(\"JASPAR.HNF1A\") #> # A tibble: 15 x 5 #>   pos          A            C            G            T #> 1   0 0.36815323 0.1725210262 0.2466605414 0.2126652060 #> 2   1 0.45927632 0.0273026316 0.4715789474 0.0418421053 #> 3   2 0.02280446 0.0642891800 0.0547671033 0.8581392528 #> 4   3 0.14734287 0.1097234161 0.0275066997 0.7154270112 #> 5   4 0.98175132 0.0002081599 0.0170691091 0.0009714127 #> 6   5 0.93368088 0.0417711495 0.0005279134 0.0240200607 #> # ... with 9 more rows"},{"path":"/reference/gextract.local_pwm.html","id":null,"dir":"Reference","previous_headings":"","what":"Extracts local position weight matrix (PWM) scores for given intervals and a PWM. — gextract.local_pwm","title":"Extracts local position weight matrix (PWM) scores for given intervals and a PWM. — gextract.local_pwm","text":"Extracts local position weight matrix (PWM) scores given intervals PWM.","code":""},{"path":"/reference/gextract.local_pwm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extracts local position weight matrix (PWM) scores for given intervals and a PWM. — gextract.local_pwm","text":"","code":"gextract.local_pwm(   intervals,   pssm,   spat = NULL,   spat_min = 0,   spat_max = NULL,   bidirect = TRUE,   prior = 0.01 )"},{"path":"/reference/gextract.local_pwm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extracts local position weight matrix (PWM) scores for given intervals and a PWM. — gextract.local_pwm","text":"intervals intervals extract pssm PSSM matrix data frame. columns matrix data frame named nucleotides ('', 'C', 'G' 'T'). spat data frame spatial model (returned $spat slot regression). contain column called 'bin' column called 'spat_factor'. spat_min minimum position use sequences. default 1. spat_max maximum position use sequences. default length sequences. bidirect motif bi-directional. TRUE, reverse-complement motif used well. prior prior probability nucleotide.","code":""},{"path":"/reference/gextract.local_pwm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extracts local position weight matrix (PWM) scores for given intervals and a PWM. — gextract.local_pwm","text":"matrix nrow(intervals) rows ncol(pssm) columns local PWM sequence position.","code":""},{"path":"/reference/gextract.local_pwm_freq.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the frequency of a position weight matrix (PWM) in a given set of intervals — gextract.local_pwm_freq","title":"Calculate the frequency of a position weight matrix (PWM) in a given set of intervals — gextract.local_pwm_freq","text":"Calculate frequency position weight matrix (PWM) given set intervals","code":""},{"path":"/reference/gextract.local_pwm_freq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the frequency of a position weight matrix (PWM) in a given set of intervals — gextract.local_pwm_freq","text":"","code":"gextract.local_pwm_freq(   intervals,   pssm,   q_threshold,   bg_intervals = NULL,   spat = NULL,   spat_min = 0,   spat_max = NULL,   bidirect = TRUE,   prior = 0.01,   n_sequences = 10000,   dist_from_edge = 3000000,   chromosomes = NULL )"},{"path":"/reference/gextract.local_pwm_freq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the frequency of a position weight matrix (PWM) in a given set of intervals — gextract.local_pwm_freq","text":"intervals intervals extract pssm PSSM matrix data frame. columns matrix data frame named nucleotides ('', 'C', 'G' 'T'). q_threshold quantile threshold PWM (e.g. 0.99 top percentile) bg_intervals (optional) intervals set background. provided, random intervals used spat data frame spatial model (returned $spat slot regression). contain column called 'bin' column called 'spat_factor'. spat_min minimum position use sequences. default 1. spat_max maximum position use sequences. default length sequences. bidirect motif bi-directional. TRUE, reverse-complement motif used well. prior prior probability nucleotide. n_sequences number sequences sample order compute quantiles. default 1e4. dist_from_edge minimum distance edge chromosome region start end(default: 3e6) chromosomes chromosomes sample (default: chromosomes)","code":""},{"path":"/reference/gextract.local_pwm_freq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the frequency of a position weight matrix (PWM) in a given set of intervals — gextract.local_pwm_freq","text":"matrix nrow(intervals) rows ncol(pssm) columns TRUE PWM threshold sequence position.","code":""},{"path":"/reference/gextract_pwm.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract pwm of intervals from a motif database — gextract_pwm_old","title":"Extract pwm of intervals from a motif database — gextract_pwm_old","text":"Extract pwm interval motif motif database. gextract_pwm_old older version function, slower, returns slightly different results due float percision instead double.","code":""},{"path":"/reference/gextract_pwm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract pwm of intervals from a motif database — gextract_pwm_old","text":"","code":"gextract_pwm_old(   intervals,   motifs = NULL,   dataset = all_motif_datasets(),   spat = NULL,   spat_min = 1,   spat_max = NULL,   bidirect = TRUE,   prior = 0.01,   func = \"logSumExp\",   parallel = getOption(\"prego.parallel\", TRUE) )  gextract_pwm(   intervals,   motifs = NULL,   dataset = MOTIF_DB,   spat = NULL,   spat_min = 1,   spat_max = NULL,   bidirect = TRUE,   prior = 0.01,   func = \"logSumExp\",   parallel = getOption(\"prego.parallel\", TRUE) )"},{"path":"/reference/gextract_pwm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract pwm of intervals from a motif database — gextract_pwm_old","text":"intervals misha intervals set motifs names specific motifs extract dataset dataset data frame PSSMs ('', 'C', 'G' 'T' columns), additional column 'motif' containing motif name, example HOMER_motifs JASPAR_motifs, all_motif_datasets(), MotifDB object. spat data frame spatial model (returned $spat slot regression). contain column called 'bin' column called 'spat_factor'. spat_min minimum position use sequences. default 1. spat_max maximum position use sequences. default length sequences. bidirect motif bi-directional. TRUE, reverse-complement motif used well. prior prior probability nucleotide. func function use combine PWMs sequence. Either 'logSumExp' 'max'. default 'logSumExp'. parallel logical, whether use parallel processing","code":""},{"path":"/reference/gextract_pwm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract pwm of intervals from a motif database — gextract_pwm_old","text":"intervals set additional columns per motif, containing pwm interval motif","code":""},{"path":"/reference/gextract_pwm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract pwm of intervals from a motif database — gextract_pwm_old","text":"","code":"if (FALSE) { # \\dontrun{ library(misha) gdb.init_examples() pwms <- gextract_pwm(gintervals.load(\"annotations\")) pwms[, 1:20] } # }"},{"path":"/reference/gextract_pwm.quantile.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract quantiles of pwm of intervals from a motif database — gextract_pwm.quantile","title":"Extract quantiles of pwm of intervals from a motif database — gextract_pwm.quantile","text":"Extract interval quantile genome motif given length. Note quantiles computed motif separately, therefore might slow intervals un-normalized lengths.","code":""},{"path":"/reference/gextract_pwm.quantile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract quantiles of pwm of intervals from a motif database — gextract_pwm.quantile","text":"","code":"gextract_pwm.quantile(   intervals,   motifs = NULL,   dataset = MOTIF_DB,   percision = 0.01,   spat = NULL,   spat_min = 1,   spat_max = NULL,   bidirect = TRUE,   prior = 0.01,   func = \"logSumExp\",   n_sequences = 10000,   dist_from_edge = 3000000,   chromosomes = NULL,   parallel = getOption(\"prego.parallel\", TRUE) )"},{"path":"/reference/gextract_pwm.quantile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract quantiles of pwm of intervals from a motif database — gextract_pwm.quantile","text":"intervals misha intervals set motifs names specific motifs extract dataset dataset data frame PSSMs ('', 'C', 'G' 'T' columns), additional column 'motif' containing motif name, example HOMER_motifs JASPAR_motifs, all_motif_datasets(), MotifDB object. percision percision quantiles. Default 0.01, means quantiles computed every 1% pwm. spat data frame spatial model (returned $spat slot regression). contain column called 'bin' column called 'spat_factor'. spat_min minimum position use sequences. default 1. spat_max maximum position use sequences. default length sequences. bidirect motif bi-directional. TRUE, reverse-complement motif used well. prior prior probability nucleotide. func function use combine PWMs sequence. Either 'logSumExp' 'max'. default 'logSumExp'. n_sequences number sequences sample order compute quantiles. default 1e4. dist_from_edge minimum distance edge chromosome region start end(default: 3e6) chromosomes chromosomes sample (default: chromosomes) parallel logical, whether use parallel processing","code":""},{"path":"/reference/gextract_pwm.quantile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract quantiles of pwm of intervals from a motif database — gextract_pwm.quantile","text":"data frame quantiles pwm interval motif. quantiles columns form {motif}.q","code":""},{"path":"/reference/gextract_pwm.quantile.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract quantiles of pwm of intervals from a motif database — gextract_pwm.quantile","text":"","code":"if (FALSE) { # \\dontrun{ library(misha) gdb.init_examples() gextract_pwm.quantile(\"annotations\", motifs = c(\"JASPAR.CDX1\", \"JASPAR.CDX2\"), dist_from_edge = 100) } # }"},{"path":"/reference/gintervals.center_by_pssm.html","id":null,"dir":"Reference","previous_headings":"","what":"Center intervals by PSSM — gintervals.center_by_pssm","title":"Center intervals by PSSM — gintervals.center_by_pssm","text":"function takes set intervals position-specific scoring matrix (PSSM) centers intervals based maximum score position PSSM. intervals shifted maximum score position becomes center interval.","code":""},{"path":"/reference/gintervals.center_by_pssm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Center intervals by PSSM — gintervals.center_by_pssm","text":"","code":"gintervals.center_by_pssm(   intervals,   pssm,   spat = NULL,   spat_min = 0,   spat_max = NULL,   bidirect = TRUE,   prior = 0.01 )"},{"path":"/reference/gintervals.center_by_pssm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Center intervals by PSSM — gintervals.center_by_pssm","text":"intervals intervals extract pssm PSSM matrix data frame. columns matrix data frame named nucleotides ('', 'C', 'G' 'T'). spat data frame spatial model (returned $spat slot regression). contain column called 'bin' column called 'spat_factor'. spat_min minimum position use sequences. default 1. spat_max maximum position use sequences. default length sequences. bidirect motif bi-directional. TRUE, reverse-complement motif used well. prior prior probability nucleotide.","code":""},{"path":"/reference/gintervals.center_by_pssm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Center intervals by PSSM — gintervals.center_by_pssm","text":"data frame containing centered intervals. intervals columns input intervals, start end positions adjusted center intervals based maximum score position PSSM.","code":""},{"path":"/reference/gpwm_quantiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute quantile of pwm for a given interval size — gpwm_quantiles","title":"Compute quantile of pwm for a given interval size — gpwm_quantiles","text":"Computes quantile pwm given interval size sampling random intervals genome, using given intervals. number sequences sample can specified n_sequences.","code":""},{"path":"/reference/gpwm_quantiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute quantile of pwm for a given interval size — gpwm_quantiles","text":"","code":"gpwm_quantiles(   size,   quantiles,   pssm,   bg_intervals = NULL,   spat = NULL,   spat_min = 1,   spat_max = NULL,   bidirect = TRUE,   prior = 0.01,   n_sequences = 10000,   dist_from_edge = 3000000,   chromosomes = NULL,   func = \"logSumExp\" )"},{"path":"/reference/gpwm_quantiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute quantile of pwm for a given interval size — gpwm_quantiles","text":"size size intervals sample quantiles quantiles compute. See quantile details. pssm PSSM matrix data frame bg_intervals (optional) intervals set background. provided, random intervals used spat data frame spatial model (returned $spat slot regression). contain column called 'bin' column called 'spat_factor'. spat_min minimum position use sequences. default 1. spat_max maximum position use sequences. default length sequences. bidirect motif bi-directional. TRUE, reverse-complement motif used well. prior prior probability nucleotide. n_sequences number sequences sample order compute quantiles. default 1e4. dist_from_edge minimum distance edge chromosome region start end(default: 3e6) chromosomes chromosomes sample (default: chromosomes) func function use combine PWMs sequence. Either 'logSumExp' 'max'. default 'logSumExp'.","code":""},{"path":"/reference/gpwm_quantiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute quantile of pwm for a given interval size — gpwm_quantiles","text":"named vector quantiles pwm given interval size.","code":""},{"path":"/reference/gpwm_quantiles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute quantile of pwm for a given interval size — gpwm_quantiles","text":"","code":"if (FALSE) { # \\dontrun{ library(misha) library(dplyr) gdb.init_examples() pssm <- JASPAR_motifs %>%     filter(motif == \"JASPAR.CDX1\") %>%     select(-motif) gpwm_quantiles(1000, seq(0, 1, 0.1), pssm, dist_from_edge = 100) } # }"},{"path":"/reference/initialize-MotifDB-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialize method for MotifDB objects — initialize,MotifDB-method","title":"Initialize method for MotifDB objects — initialize,MotifDB-method","text":"Initialize method MotifDB objects","code":""},{"path":"/reference/initialize-MotifDB-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialize method for MotifDB objects — initialize,MotifDB-method","text":"","code":"# S4 method for class 'MotifDB' initialize(   .Object,   mat = matrix(0, 4, 1),   rc_mat = matrix(0, 4, 1),   motif_lengths = setNames(as.integer(1), colnames(mat)[1]),   prior = 0.01,   spat_factors = matrix(1, nrow = 1, ncol = 1),   spat_bin_size = 1 )"},{"path":"/reference/initialize-MotifDB-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialize method for MotifDB objects — initialize,MotifDB-method","text":".Object MotifDB object mat Position weight matrix rc_mat Reverse complement matrix motif_lengths Named vector motif lengths prior Pseudocount prior value spat_factors Matrix spatial factors spat_bin_size Size spatial bins","code":""},{"path":"/reference/intervals_to_seq.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert intervals to sequences — intervals_to_seq","title":"Convert intervals to sequences — intervals_to_seq","text":"function takes set intervals converts sequences. requires 'misha' package installed. package installed, display error message instructions install .","code":""},{"path":"/reference/intervals_to_seq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert intervals to sequences — intervals_to_seq","text":"","code":"intervals_to_seq(intervals)"},{"path":"/reference/intervals_to_seq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert intervals to sequences — intervals_to_seq","text":"intervals intervals set data frame 'chrom', 'start', 'end' columns.","code":""},{"path":"/reference/intervals_to_seq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert intervals to sequences — intervals_to_seq","text":"character vector sequences.","code":""},{"path":"/reference/intervals_to_seq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert intervals to sequences — intervals_to_seq","text":"","code":"if (FALSE) { # \\dontrun{ library(misha) gdb.init_examples() intervals_to_seq(gintervals.load(\"annotations\")) } # }"},{"path":"/reference/kmer_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a kmer Matrix — kmer_matrix","title":"Generate a kmer Matrix — kmer_matrix","text":"function calculates frequency kmer DNA sequence.","code":""},{"path":"/reference/kmer_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a kmer Matrix — kmer_matrix","text":"","code":"kmer_matrix(   sequences,   kmer_length,   max_gap = 0,   mask = NULL,   add_mask = FALSE,   from_range = 1,   to_range = NULL,   set_rownames = FALSE )"},{"path":"/reference/kmer_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a kmer Matrix — kmer_matrix","text":"sequences vector strings DNA sequences ('T', 'C', 'G', '' 'N'). kmer_length length kmers considered. max_gap maximum length gap considered pattern. Default: 0 mask string length kmer_length 'N' indicates wildcard position (default NULL - mask). add_mask TRUE, result mask added non-masked kmers. Otherwise - masked kmers returned. from_range Sequences considered position from_range. to_range Sequences considered position to_range (default NULL - using length sequences). set_rownames TRUE, rownames matrix set sequences (default FALSE).","code":""},{"path":"/reference/kmer_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a kmer Matrix — kmer_matrix","text":"matrix rows number sequences, columns kmers values number occurrences kmer.","code":""},{"path":"/reference/kmer_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a kmer Matrix — kmer_matrix","text":"","code":"kmer_matrix(c(\"ATCG\", \"TCGA\", \"ATAT\"), 2) #>      CG AT TC GA TA #> [1,]  1  1  1  0  0 #> [2,]  1  0  1  1  0 #> [3,]  0  2  0  0  1 kmer_matrix(c(\"ATCG\", \"TCGA\", \"ATAT\"), 3) #>      TCG ATC CGA TAT ATA #> [1,]   1   1   0   0   0 #> [2,]   1   0   1   0   0 #> [3,]   0   0   0   1   1 kmer_matrix(c(\"ATCG\", \"TCGA\", \"ATAT\"), 3, mask = \"ATN\") #>      TCN ATN CGN TAN #> [1,]   1   1   0   0 #> [2,]   1   0   1   0 #> [3,]   0   1   0   1"},{"path":"/reference/kmers_to_pssm.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform k-mers to PSSM (Position-Specific Scoring Matrix) — kmers_to_pssm","title":"Transform k-mers to PSSM (Position-Specific Scoring Matrix) — kmers_to_pssm","text":"function transforms vector k-mers position-specific scoring matrix (PSSM). PSSM represents frequency nucleotide position k-mers. nucleotide 'N', treated equal probabilities '', 'C', 'G', 'T'. result returned data frame columns k-mer, position, nucleotide frequencies.","code":""},{"path":"/reference/kmers_to_pssm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform k-mers to PSSM (Position-Specific Scoring Matrix) — kmers_to_pssm","text":"","code":"kmers_to_pssm(kmers, prior = 0.01)"},{"path":"/reference/kmers_to_pssm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform k-mers to PSSM (Position-Specific Scoring Matrix) — kmers_to_pssm","text":"kmers character vector k-mers. prior numeric value indicating prior probability nucleotide. Default 0.01.","code":""},{"path":"/reference/kmers_to_pssm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform k-mers to PSSM (Position-Specific Scoring Matrix) — kmers_to_pssm","text":"data frame columns k-mer, position, nucleotide frequencies, 'kmer', 'pos', '', 'C', 'G', 'T'.","code":""},{"path":"/reference/kmers_to_pssm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform k-mers to PSSM (Position-Specific Scoring Matrix) — kmers_to_pssm","text":"","code":"kmers_to_pssm(c(\"ACGTN\", \"TGCAN\"), prior = 0.01) #>     kmer pos           A           C           G           T #> 1  ACGTN   1 0.970873786 0.009708738 0.009708738 0.009708738 #> 2  ACGTN   2 0.009708738 0.970873786 0.009708738 0.009708738 #> 3  ACGTN   3 0.009708738 0.009708738 0.970873786 0.009708738 #> 4  ACGTN   4 0.009708738 0.009708738 0.009708738 0.970873786 #> 5  ACGTN   5 0.250000000 0.250000000 0.250000000 0.250000000 #> 6  TGCAN   1 0.009708738 0.009708738 0.009708738 0.970873786 #> 7  TGCAN   2 0.009708738 0.009708738 0.970873786 0.009708738 #> 8  TGCAN   3 0.009708738 0.970873786 0.009708738 0.009708738 #> 9  TGCAN   4 0.970873786 0.009708738 0.009708738 0.009708738 #> 10 TGCAN   5 0.250000000 0.250000000 0.250000000 0.250000000"},{"path":"/reference/length-MotifDB-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the length of a MotifDB object — length,MotifDB-method","title":"Get the length of a MotifDB object — length,MotifDB-method","text":"Get length MotifDB object","code":""},{"path":"/reference/length-MotifDB-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the length of a MotifDB object — length,MotifDB-method","text":"","code":"# S4 method for class 'MotifDB' length(x)"},{"path":"/reference/length-MotifDB-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the length of a MotifDB object — length,MotifDB-method","text":"x MotifDB object","code":""},{"path":"/reference/length-MotifDB-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the length of a MotifDB object — length,MotifDB-method","text":"number motifs object","code":""},{"path":"/reference/load_multi_regression.html","id":null,"dir":"Reference","previous_headings":"","what":"Load a multiple motif regression model from a file — load_multi_regression","title":"Load a multiple motif regression model from a file — load_multi_regression","text":"Load multiple motif regression model file","code":""},{"path":"/reference/load_multi_regression.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load a multiple motif regression model from a file — load_multi_regression","text":"","code":"load_multi_regression(   fn,   response = NULL,   sequences = NULL,   motif_dataset = all_motif_datasets(),   parallel = getOption(\"prego.parallel\", FALSE),   alternative = \"two.sided\" )"},{"path":"/reference/load_multi_regression.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load a multiple motif regression model from a file — load_multi_regression","text":"fn file name list model response matrix response variables - number rows equal number sequences sequences vector DNA sequences ('', 'T', 'C' 'G'. go toupper). Please make sure sequences long enough cover spat_num_bins * spat_bin_size bp, centered around motif/signal. motif_dataset data frame PSSMs ('', 'C', 'G' 'T' columns), additional column 'motif' containing motif name, example HOMER_motifs, JASPAR_motifs all_motif_datasets(). default all_motif_datasets() used. parallel whether run optimization parallel. use set_parallel set number cores use. alternative alternative hypothesis p-value calculation using ks.test. One \"two.sided\", \"less\" \"greater\".","code":""},{"path":"/reference/load_multi_regression.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load a multiple motif regression model from a file — load_multi_regression","text":"list following elements: models: list models. model: combined model. spat_min: minimum spatial position. spat_max: maximum spatial position. bidirect: whether model bidirectional. spat_bin_size: spatial bin size. seq_length: sequence length. motif_num: number motifs. predict: function predict response. predict_multi: function predict response motif.","code":""},{"path":"/reference/load_multi_regression.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Load a multiple motif regression model from a file — load_multi_regression","text":"","code":"if (FALSE) { # \\dontrun{ res_multi <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1],     final_metric = \"ks\", spat_bin_size = 40,     spat_num_bins = 7,     motif_num = 2 ) tmp <- tempfile() res_multi$export(tmp) r <- load_multi_regression(tmp) } # }"},{"path":"/reference/load_regression_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Load a motif regression model from a file — load_regression_model","title":"Load a motif regression model from a file — load_regression_model","text":"Load motif regression model file","code":""},{"path":"/reference/load_regression_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load a motif regression model from a file — load_regression_model","text":"","code":"load_regression_model(fn)"},{"path":"/reference/load_regression_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load a motif regression model from a file — load_regression_model","text":"fn file name list model","code":""},{"path":"/reference/load_regression_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load a motif regression model from a file — load_regression_model","text":"list following elements: pssm: data frame PSSM spat: data frame spatial profile spat_min: numeric value minimum value spatial profile spat_max: numeric value maximum value spatial profile bidirect: boolean value indicating whether model bidirectional seq_length: numeric value length sequences","code":""},{"path":"/reference/load_regression_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Load a motif regression model from a file — load_regression_model","text":"","code":"if (FALSE) { # \\dontrun{ res <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1],     final_metric = \"ks\", spat_bin_size = 40,     spat_num_bins = 7 ) export_fn <- tempfile() export_regression_model(export_fn) r <- load_regression(export_fn) } # }"},{"path":"/reference/mask_sequences_by_pwm.html","id":null,"dir":"Reference","previous_headings":"","what":"Mask sequences by thresholding the PWM — mask_sequences_by_pwm","title":"Mask sequences by thresholding the PWM — mask_sequences_by_pwm","text":"Mask sequences thresholding PWM. Sequences PWM threshold masked 'N'. Sequences edges sequences also masked 'N'.","code":""},{"path":"/reference/mask_sequences_by_pwm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mask sequences by thresholding the PWM — mask_sequences_by_pwm","text":"","code":"mask_sequences_by_pwm(   sequences,   pssm,   mask_thresh,   pos_bits_thresh = 0.2,   spat = NULL,   spat_min = 0,   spat_max = NULL,   bidirect = TRUE,   prior = 0.01 )"},{"path":"/reference/mask_sequences_by_pwm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mask sequences by thresholding the PWM — mask_sequences_by_pwm","text":"sequences vector sequences pssm PSSM matrix data frame. columns matrix data frame named nucleotides ('', 'C', 'G' 'T'). mask_thresh Threshold masking. Sequences PWM threshold masked 'N'. pos_bits_thresh Mask positions amount information contributed (Shannon entropy, measured bits) threshold. scale y axis pssm logo plots. spat data frame spatial model (returned $spat slot regression). contain column called 'bin' column called 'spat_factor'. spat_min minimum position use sequences. default 1. spat_max maximum position use sequences. default length sequences. bidirect motif bi-directional. TRUE, reverse-complement motif used well. prior prior probability nucleotide.","code":""},{"path":"/reference/mask_sequences_by_pwm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mask sequences by thresholding the PWM — mask_sequences_by_pwm","text":"vector masked sequences.","code":""},{"path":"/reference/mask_sequences_by_pwm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mask sequences by thresholding the PWM — mask_sequences_by_pwm","text":"","code":"res <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1]) #> ℹ Using 7 bins of size 40 bp #> ℹ Using \"ks\" as the final metric #> ℹ Number of response variables: 1 #>  #> ── Generate candidate kmers  #>  #> ── Regress each candidate kmer  #> ℹ Running regression on 10 candidate kmers #> • Bidirectional: TRUE #> • Spat bin size: 40 #> • Number of spatial bins 7 #> • Length of sequence: 280 #> • Min gap: 0 #> • Max gap: 1 #> • Kmer length: 8 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> • kmer: \"TTAAT*ATT\", score (ks): 0.847160350285881 #> • kmer: \"AAT*ATTAA\", score (ks): 0.843616775749975 #> • kmer: \"TAAT*ATTA\", score (ks): 0.850689772296759 #> • kmer: \"GTTAAT*AT\", score (ks): 0.838714558811362 #> • kmer: \"AT*ATTAAC\", score (ks): 0.838920314752157 #> • kmer: \"AA*CATTAA\", score (ks): 0.846266563897562 #> • kmer: \"TTAA*CATT\", score (ks): 0.84705039605297 #> • kmer: \"TAATCATT\", score (ks): 0.844248196097387 #> • kmer: \"TTA*TCATT\", score (ks): 0.852612338389051 #> • kmer: \"TAA*CATTA\", score (ks): 0.845319433376444 #> ℹ Best match in the database: \"JOLMA.HNF1B_di_full_1\", cor: 0.784 #> ✔ \"JOLMA.HNF1B_di_full_1\" KS test D: 0.8484, p-value: 0 #> ℹ Best motif: \"***TTA*TCATT***\", score (ks): 0.852612338389051 new_sequences <- mask_sequences_by_pwm(     cluster_sequences_example,     res$pssm,     quantile(res$pred, 0.95),     spat = res$spat ) #> ℹ The following positions will be masked: 4, 5, 6, 7, 8, 10, 11, and 12. Overall 8 positions will be masked  head(new_sequences) #> [1] \"CAGTAAAAGCTTTAATGCGTCTTGAGAGGGAGAGCATCAGCTTACAGAGCGAAGACCCCGAATGGCAAAACCCCGTCCCTTTTATGGAGAATTGCCCTCCGCCTCAGACACGTCGCTCCCTGATTGGCTGCAGCCCATCGGCCGAGTTGTCCTCACGGGGAAGGCAGAGCACATGGAGTGGAAAACTACCCCGGGCACATGCACAGATTACTTGTTTACTACTTAGAACACAGGATGTCAGCACCATCTTGTAATGGCGAATGTGAGGGCGGCTCCTCATACTTANNNNNNNNNNNNNNN\" #> [2] \"AATTGCTTCATTAAAACCAAGTTTTTCTTTGTTCATTAGGCGTTAGCCAGATGGGAATTCAGTGTTTTTAAGCAGACACTCACATGGGGTTTTGTTTCTGACATTGATGAATGACTGCCTGCATCCCAAGATGGAAGTTTCCACCCTGGGCTCTGACTGCAACTTTTGTTATTCATAGCAGAAGTCACACCAGTCCACAGCTGAATAGCCACAGTGTTAAGAACAGCTGTCTTACAGCACTGTATGTGGAGAACAGAAAGAGCGGGGTCAAGACTGGTCGCATTGNNNNNNNNNNNNNNN\" #> [3] \"GAGTGAGGTGTAAACTGAGCACCCCTTTTTATGGTCTTCACTGTTGCTAGGTAACTGGGGAGGAGTTTAGCCTGAAGGTCAGAAGCTTGGGCCATTGATTATGTGACTACTGACCCTGCTTCTCTTGTGGGGGCTGTGGGAGGTGGTACCTTAGGCAGGGGCCGAGTTCCAGGAGCATGAGGGAACGCCCACTGTGTCATGTAGGTGATTTATGGCCATCGGGTTTCAGACCTCAGCTCGACTGGAGACCAGCCTGCAATTCCCCACAGGAAACTTTATAAGAACNNNNNNNNNNNNNNN\" #> [4] \"TTCACTGAAGGTTTAAAACCATAGCTAAGTTATTAGTGAAGTTTTGTAGAGATAAGCCCAGTTGGTATTTTATCTTCTGTCCTAGCACCTACAATAAATCATTAGCTGCTTTTTAATGACCTTTGGTTAATTGTTTTACAACCTCTTGGAATGTGCTCTTAGTAGGAGAAAGTCTGGTTACCATCTAAGAGCAATTAACTGGTGACACTTGGGAGGCTGGCAGAGTTCTCATTGCAGCTTTGACTATCAGAAAAGGACCTAATAGCAGTCCTGTTACAAAAGAGCNNNNNNNNNNNNNNN\" #> [5] \"CATGTTACGCTCCATCACTGAGAGACAAGGGTAGGAGCTCAGGGAGGAACCTAATCCAGAAACTGACAGCAGAACCAAAAACGACCACTGATATCTGACTTGCTCTCTGTGTCTGGCTCAGCTGCCTTCCATGTACATCCCAGGACCCACAGAGTGACACAGGCCACAATGGCTGGACCCTCCCACATCAATCATTAATCAAGAGAATGTTTGCCAGACATGCCCACAGACCAATCTGACGGAGGCAGCTCCTCAGCTGAGGCTCCCTTTCCCAGGCGGCTACTGNNNNNNNNNNNNNNN\" #> [6] \"AATTTGTATTTAACTATTTCTGGTTACTTAGCTGTGTGTCCTACCTCTGTGTTTGCTGTAGGATTGCAGTTTGATTCCAGCCAACCTTGCAGAGGCATTTGGATTACTGATTAACTGCAGTGAGGCATCTCCTTGCCACCCACTTCTTCCTACTGTGCAGCACACTTTAAAGAAAGCAGTGGAGCCTGAGGGGCTGCTGTACTTAGCGTCTAAGCAGTTCACAACTGAAGACTTTGAAAAGGTAAAGTTAGATAAAATGATTACTCAGAATGCCTACTCGTTTCTNNNNNNNNNNNNNNN\""},{"path":"/reference/motif_db_to_dataframe.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a MotifDB object back to a tidy data frame — motif_db_to_dataframe","title":"Convert a MotifDB object back to a tidy data frame — motif_db_to_dataframe","text":"Convert MotifDB object back tidy data frame","code":""},{"path":"/reference/motif_db_to_dataframe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a MotifDB object back to a tidy data frame — motif_db_to_dataframe","text":"","code":"motif_db_to_dataframe(motif_db)"},{"path":"/reference/motif_db_to_dataframe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a MotifDB object back to a tidy data frame — motif_db_to_dataframe","text":"motif_db MotifDB object","code":""},{"path":"/reference/motif_db_to_dataframe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a MotifDB object back to a tidy data frame — motif_db_to_dataframe","text":"tidy data frame columns motif, position, nucleotide probabilities","code":""},{"path":"/reference/motif_enrichment.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate motif enrichment — motif_enrichment","title":"Calculate motif enrichment — motif_enrichment","text":"Calculates motif enrichment groups loci (usually clusters).","code":""},{"path":"/reference/motif_enrichment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate motif enrichment — motif_enrichment","text":"","code":"motif_enrichment(pwm_q, groups, threshold = 0.99, type = \"relative\")"},{"path":"/reference/motif_enrichment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate motif enrichment — motif_enrichment","text":"pwm_q matrix representing quantile values position weight matrix (PWM). output gextract_pwm.quantile. groups character vector factor specifying groups sequence belongs. Usually clustering result. threshold threshold value considering position PWM significant. Default 0.99. type type enrichment calculation perform. Possible values \"relative\" (default) \"absolute\".","code":""},{"path":"/reference/motif_enrichment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate motif enrichment — motif_enrichment","text":"matrix representing motif enrichment values group. type = \"relative\", values relative enrichment motif group compared loci groups. type = \"absolute\", values enrichment motif compared random genome.","code":""},{"path":"/reference/motif_enrichment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate motif enrichment — motif_enrichment","text":"","code":"if (FALSE) { # \\dontrun{ library(misha) gdb.init_examples() annot <- misha.ext::gintervals.normalize(gintervals.load(\"annotations\"), 300) pwm_q <- gextract_pwm.quantile(     annot,     motifs = c(\"JASPAR.CDX1\", \"JASPAR.CDX2\"),     dist_from_edge = 100 ) pwm_q <- as.matrix(pwm_q[, c(\"JASPAR.CDX1.q\", \"JASPAR.CDX2.q\")]) groups <- c(\"Group1\", \"Group1\", \"Group2\", \"Group2\", \"Group2\", \"Group3\", \"Group3\", \"Group3\")  # The threshold of 0.1 is used for demonstration purposes only. # In practice, a threshold of 0.99 is recommended. motif_enrichment(pwm_q, groups, threshold = 0.1, type = \"relative\") motif_enrichment(pwm_q, groups, threshold = 0.1, type = \"absolute\") } # }"},{"path":"/reference/names-MotifDB-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the names of motifs in a MotifDB object — names,MotifDB-method","title":"Get the names of motifs in a MotifDB object — names,MotifDB-method","text":"Get names motifs MotifDB object","code":""},{"path":"/reference/names-MotifDB-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the names of motifs in a MotifDB object — names,MotifDB-method","text":"","code":"# S4 method for class 'MotifDB' names(x)"},{"path":"/reference/names-MotifDB-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the names of motifs in a MotifDB object — names,MotifDB-method","text":"x MotifDB object","code":""},{"path":"/reference/names-MotifDB-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the names of motifs in a MotifDB object — names,MotifDB-method","text":"names motifs object","code":""},{"path":"/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"/reference/plot-MotifDB-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a motif from a MotifDB object — plot,MotifDB-method","title":"Plot a motif from a MotifDB object — plot,MotifDB-method","text":"Plot motif MotifDB object","code":""},{"path":"/reference/plot-MotifDB-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a motif from a MotifDB object — plot,MotifDB-method","text":"","code":"# S4 method for class 'MotifDB' plot(   x,   title = \"\",   subtitle = ggplot2::waiver(),   revcomp = FALSE,   method = \"bits\",   ... )"},{"path":"/reference/plot-MotifDB-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a motif from a MotifDB object — plot,MotifDB-method","text":"x MotifDB object title title plot subtitle subtitle plot revcomp whether plot reverse complement PSSM method Height method, can one \"bits\" \"probability\" (default:\"bits\") ... Arguments passed ggseqlogo::ggseqlogo data Character vector sequences named list sequences. sequences must width facet Facet type, can 'wrap' 'grid' scales Facet scales, see facet_wrap ncol Number columns, works facet='wrap', see facet_wrap nrow Number rows, ncol","code":""},{"path":"/reference/plot_pssm_logo.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot LOGO of the pssm result from the regression — plot_pssm_logo","title":"Plot LOGO of the pssm result from the regression — plot_pssm_logo","text":"Plot LOGO pssm result regression","code":""},{"path":"/reference/plot_pssm_logo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot LOGO of the pssm result from the regression — plot_pssm_logo","text":"","code":"plot_pssm_logo(   pssm,   title = \"Sequence model\",   subtitle = ggplot2::waiver(),   pos_bits_thresh = NULL,   revcomp = FALSE,   method = \"bits\" )"},{"path":"/reference/plot_pssm_logo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot LOGO of the pssm result from the regression — plot_pssm_logo","text":"pssm PSSM matrix data frame title title plot subtitle subtitle plot pos_bits_thresh Positions bits threshold highlighted red. NULL, positions highlighted. revcomp whether plot reverse complement PSSM method Height method, can one \"bits\" \"probability\" (default:\"bits\")","code":""},{"path":"/reference/plot_pssm_logo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot LOGO of the pssm result from the regression — plot_pssm_logo","text":"ggplot object","code":""},{"path":"/reference/plot_pssm_logo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot LOGO of the pssm result from the regression — plot_pssm_logo","text":"","code":"pssm <- data.frame(     pos = seq(0, 9, by = 1),     A = c(         0.16252439817826936, 0.4519127838188067, 0, 1, 0, 0.9789171974522293,         0.9743866100297978, 0.013113942843003835, 0.3734676916683981,         0.32658771473191045     ),     C = c(         0.43038386467143785, 0.13116231900388756, 0, 0, 0, 0, 0, 0.46975132995175056,         0.1669956368169541, 0.29795679333680375     ),     G = c(         0.22999349381912818, 0.002929742520705392, 1, 0, 0, 0, 0.012679896024852597,         0.4808858097241123, 0.4248389777685435, 0.20458094742321709     ),     T = c(         0.1770982433311646, 0.41399515465660036, 0, 0, 1, 0.0210828025477707,         0.012933493945349648, 0.03624891748113324, 0.0346976937461043,         0.17087454450806872     ) ) plot_pssm_logo(pssm) #> Warning: The `<scale>` argument of `guides()` cannot be `FALSE`. Use \"none\" instead as of #> ggplot2 3.3.4. #> ℹ The deprecated feature was likely used in the ggseqlogo package. #>   Please report the issue at <https://github.com/omarwagih/ggseqlogo/issues>.  if (FALSE) { # \\dontrun{ res <- regress_pwm(sequences_example, response_mat_example) plot_pssm_logo(res$pssm) } # }"},{"path":"/reference/plot_pssm_logo_dataset.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot LOGO of pssm from dataset (e.g. ","title":"Plot LOGO of pssm from dataset (e.g. ","text":"Plot LOGO pssm dataset (e.g. \"HOMER\" \"JASPAR\")","code":""},{"path":"/reference/plot_pssm_logo_dataset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot LOGO of pssm from dataset (e.g. ","text":"","code":"plot_pssm_logo_dataset(   motif,   dataset = all_motif_datasets(),   title = motif,   subtitle = ggplot2::waiver(),   pos_bits_thresh = NULL,   revcomp = FALSE,   method = \"bits\" )"},{"path":"/reference/plot_pssm_logo_dataset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot LOGO of pssm from dataset (e.g. ","text":"motif motif name (e.g. \"GATA4\") dataset data frame PSSMs ('', 'C', 'G' 'T' columns), additional column 'motif' containing motif name, example HOMER_motifs, JASPAR_motifs all_motif_datasets() title title plot subtitle subtitle plot pos_bits_thresh Positions bits threshold highlighted red. NULL, positions highlighted. revcomp whether plot reverse complement PSSM method Height method, can one \"bits\" \"probability\" (default:\"bits\")","code":""},{"path":"/reference/plot_pssm_logo_dataset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot LOGO of pssm from dataset (e.g. ","text":"ggplot object","code":""},{"path":"/reference/plot_pssm_logo_dataset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot LOGO of pssm from dataset (e.g. ","text":"","code":"plot_pssm_logo_dataset(\"JASPAR.Brachyury\")   plot_pssm_logo_dataset(\"GATA5\", JASPAR_motifs)"},{"path":"/reference/plot_regression_prediction.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot response variable averages vs the regression model's prediction — plot_regression_prediction","title":"Plot response variable averages vs the regression model's prediction — plot_regression_prediction","text":"return scatter plot response variable averages vs regression model's prediction","code":""},{"path":"/reference/plot_regression_prediction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot response variable averages vs the regression model's prediction — plot_regression_prediction","text":"","code":"plot_regression_prediction(pred, response, point_size = 0.5, alpha = 1)"},{"path":"/reference/plot_regression_prediction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot response variable averages vs the regression model's prediction — plot_regression_prediction","text":"pred 'pred' field regression result response 'response' field regression result (response variable) point_size size points plot (default: 0.5) alpha transparency points plot (default: 1)","code":""},{"path":"/reference/plot_regression_prediction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot response variable averages vs the regression model's prediction — plot_regression_prediction","text":"","code":"if (FALSE) { # \\dontrun{ res <- regress_pwm(sequences_example, response_mat_example) plot_regression_prediction(res$pred, res$response) } # }"},{"path":"/reference/plot_regression_prediction_binary.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the cumulative of the regression model's prediction stratified by the response variable — plot_regression_prediction_binary","title":"Plot the cumulative of the regression model's prediction stratified by the response variable — plot_regression_prediction_binary","text":"Plot cumulative regression model's prediction stratified response variable","code":""},{"path":"/reference/plot_regression_prediction_binary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the cumulative of the regression model's prediction stratified by the response variable — plot_regression_prediction_binary","text":"","code":"plot_regression_prediction_binary(pred, response)"},{"path":"/reference/plot_regression_prediction_binary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the cumulative of the regression model's prediction stratified by the response variable — plot_regression_prediction_binary","text":"pred 'pred' field regression result response 'response' field regression result (response variable). binary (0/1).","code":""},{"path":"/reference/plot_regression_prediction_binary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the cumulative of the regression model's prediction stratified by the response variable — plot_regression_prediction_binary","text":"","code":"if (FALSE) { # \\dontrun{ res_binary <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1], score_metric = \"ks\") plot_regression_prediction_binary(res_binary$pred, res_binary$response) } # }"},{"path":"/reference/plot_regression_qc.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the regression results — plot_regression_qc","title":"Plot the regression results — plot_regression_qc","text":"Plot QC regression results","code":""},{"path":"/reference/plot_regression_qc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the regression results — plot_regression_qc","text":"","code":"plot_regression_qc(   reg,   response = NULL,   title = glue(\"Motif regression results (consensus: {reg$consensus})\"),   subtitle = NULL,   caption = NULL,   point_size = 0.5,   alpha = 0.5 )"},{"path":"/reference/plot_regression_qc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the regression results — plot_regression_qc","text":"reg output regress_pwm response response variable title title plot (optional) subtitle subtitle plot (optional) caption caption plot (optional). caption NULL default caption plotted. point_size size points scatter plot alpha transparency points scatter plot","code":""},{"path":"/reference/plot_regression_qc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the regression results — plot_regression_qc","text":"patchwork object","code":""},{"path":"/reference/plot_regression_qc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the regression results — plot_regression_qc","text":"","code":"if (FALSE) { # \\dontrun{ res <- regress_pwm(sequences_example, response_mat_example) plot_regression_qc(res)  res_binary <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1], screen_db = TRUE) plot_regression_qc(res_binary) } # }"},{"path":"/reference/plot_regression_qc_multi.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the regression results for multiple motifs — plot_regression_qc_multi","title":"Plot the regression results for multiple motifs — plot_regression_qc_multi","text":"plot regression results motif_num > 1","code":""},{"path":"/reference/plot_regression_qc_multi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the regression results for multiple motifs — plot_regression_qc_multi","text":"","code":"plot_regression_qc_multi(   reg,   title = glue(\"Motif regression results (consensus: {reg$consensus})\"),   subtitle = NULL,   caption = NULL,   point_size = 0.01,   alpha = 0.5,   response = NULL )"},{"path":"/reference/plot_regression_qc_multi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the regression results for multiple motifs — plot_regression_qc_multi","text":"reg output regress_pwm title title plot (optional) subtitle subtitle plot (optional) caption caption plot (optional). caption NULL default caption plotted. point_size size points scatter plot alpha transparency points scatter plot response response variable","code":""},{"path":"/reference/plot_regression_qc_multi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the regression results for multiple motifs — plot_regression_qc_multi","text":"","code":"if (FALSE) { # \\dontrun{ res_binary <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 3], motif_num = 3) plot_regression_qc_multi(res_binary) } # }"},{"path":"/reference/plot_spat_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot spatial model of the regression result — plot_spat_model","title":"Plot spatial model of the regression result — plot_spat_model","text":"Plot spatial model regression result","code":""},{"path":"/reference/plot_spat_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot spatial model of the regression result — plot_spat_model","text":"","code":"plot_spat_model(spat, title = \"Spatial model\")"},{"path":"/reference/plot_spat_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot spatial model of the regression result — plot_spat_model","text":"spat 'spat' field regression result title title plot (optional)","code":""},{"path":"/reference/plot_spat_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot spatial model of the regression result — plot_spat_model","text":"","code":"if (FALSE) { # \\dontrun{ res <- regress_pwm(sequences_example, response_mat_example) plot_spat_model(res$spat) } # }"},{"path":"/reference/prego-package.html","id":null,"dir":"Reference","previous_headings":"","what":"prego: PWM Regression Optimizer — prego-package","title":"prego: PWM Regression Optimizer — prego-package","text":"PREGO implements regression algorithms finding motifs DNA. contains algorithms described : \"Extensive low-affinity transcriptional interactions yeast genome\" doi:10.1101/gr.5113606 .","code":""},{"path":"/reference/prego-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"prego: PWM Regression Optimizer — prego-package","text":"Maintainer: Aviezer Lifshitz aviezer.lifshitz@weizmann.ac.il Authors: Amos Tanay amos.tanay@weizmann.ac.il","code":""},{"path":"/reference/prior-MotifDB-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the prior value from a MotifDB object — prior,MotifDB-method","title":"Get the prior value from a MotifDB object — prior,MotifDB-method","text":"Get prior value MotifDB object","code":""},{"path":"/reference/prior-MotifDB-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the prior value from a MotifDB object — prior,MotifDB-method","text":"","code":"# S4 method for class 'MotifDB' prior(object)"},{"path":"/reference/prior-MotifDB-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the prior value from a MotifDB object — prior,MotifDB-method","text":"object MotifDB object","code":""},{"path":"/reference/prior-MotifDB-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the prior value from a MotifDB object — prior,MotifDB-method","text":"prior value","code":""},{"path":"/reference/prior-set-MotifDB-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Set a new prior for a MotifDB object — prior<-,MotifDB-method","title":"Set a new prior for a MotifDB object — prior<-,MotifDB-method","text":"Set new prior MotifDB object","code":""},{"path":"/reference/prior-set-MotifDB-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set a new prior for a MotifDB object — prior<-,MotifDB-method","text":"","code":"# S4 method for class 'MotifDB' prior(object) <- value"},{"path":"/reference/prior-set-MotifDB-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set a new prior for a MotifDB object — prior<-,MotifDB-method","text":"object MotifDB object value New prior value 0 1","code":""},{"path":"/reference/prior-set-MotifDB-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set a new prior for a MotifDB object — prior<-,MotifDB-method","text":"Updated MotifDB object new prior","code":""},{"path":"/reference/prior-set.html","id":null,"dir":"Reference","previous_headings":"","what":"Set the prior for a MotifDB object — prior<-","title":"Set the prior for a MotifDB object — prior<-","text":"Set prior MotifDB object","code":""},{"path":"/reference/prior-set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set the prior for a MotifDB object — prior<-","text":"","code":"prior(object) <- value"},{"path":"/reference/prior-set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set the prior for a MotifDB object — prior<-","text":"object MotifDB object value New prior value","code":""},{"path":"/reference/prior-set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set the prior for a MotifDB object — prior<-","text":"Updated MotifDB object","code":""},{"path":"/reference/prior.html","id":null,"dir":"Reference","previous_headings":"","what":"Get or set the prior for a MotifDB object — prior","title":"Get or set the prior for a MotifDB object — prior","text":"Get set prior MotifDB object","code":""},{"path":"/reference/prior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get or set the prior for a MotifDB object — prior","text":"","code":"prior(object)"},{"path":"/reference/prior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get or set the prior for a MotifDB object — prior","text":"object MotifDB object","code":""},{"path":"/reference/prior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get or set the prior for a MotifDB object — prior","text":"prior value","code":""},{"path":"/reference/pssm_cor.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the correlation between two given PSSMs — pssm_cor","title":"Compute the correlation between two given PSSMs — pssm_cor","text":"correlation computed shifting shorter PSSM along longer one computing correlation position. maximum correlation returned.","code":""},{"path":"/reference/pssm_cor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the correlation between two given PSSMs — pssm_cor","text":"","code":"pssm_cor(pssm1, pssm2, method = \"spearman\", prior = 0.01)"},{"path":"/reference/pssm_cor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the correlation between two given PSSMs — pssm_cor","text":"pssm1 first PSSM matrix data frame pssm2 second PSSM matrix data frame method method use computing correlation. See cor details. prior prior probability nucleotide.","code":""},{"path":"/reference/pssm_cor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the correlation between two given PSSMs — pssm_cor","text":"Correlation two PSSMs","code":""},{"path":"/reference/pssm_cor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute the correlation between two given PSSMs — pssm_cor","text":"","code":"if (FALSE) { # \\dontrun{ res1 <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1]) pssm_cor(res1$pssm, JASPAR_motifs[JASPAR_motifs$motif == \"HNF1A\", ]) } # }"},{"path":"/reference/pssm_dataset_cor.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute a correlation matrix for a pssm dataset — pssm_dataset_cor","title":"Compute a correlation matrix for a pssm dataset — pssm_dataset_cor","text":"Compute correlation matrix pssm dataset","code":""},{"path":"/reference/pssm_dataset_cor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute a correlation matrix for a pssm dataset — pssm_dataset_cor","text":"","code":"pssm_dataset_cor(   dataset,   method = \"spearman\",   prior = 0.01,   parallel = getOption(\"prego.parallel\", TRUE) )"},{"path":"/reference/pssm_dataset_cor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute a correlation matrix for a pssm dataset — pssm_dataset_cor","text":"dataset pssm dataset. data frame columns 'motif', 'pos', '\", 'C', 'G', 'T' method method use computing correlation. See cor details. prior prior probability nucleotide. parallel whether use parallel computing","code":""},{"path":"/reference/pssm_dataset_cor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute a correlation matrix for a pssm dataset — pssm_dataset_cor","text":"correlation matrix PSSMs dataset","code":""},{"path":"/reference/pssm_dataset_cor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute a correlation matrix for a pssm dataset — pssm_dataset_cor","text":"","code":"if (FALSE) { # \\dontrun{ cm <- pssm_dataset_cor(JASPAM_motifs) head(cm) } # }"},{"path":"/reference/pssm_diff.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute KL divergence between two PSSMs — pssm_diff","title":"Compute KL divergence between two PSSMs — pssm_diff","text":"Compute KL divergence two PSSMs","code":""},{"path":"/reference/pssm_diff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute KL divergence between two PSSMs — pssm_diff","text":"","code":"pssm_diff(pssm1, pssm2)"},{"path":"/reference/pssm_diff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute KL divergence between two PSSMs — pssm_diff","text":"pssm1 first PSSM matrix data frame pssm2 second PSSM matrix data frame","code":""},{"path":"/reference/pssm_diff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute KL divergence between two PSSMs — pssm_diff","text":"KL divergence two PSSMs","code":""},{"path":"/reference/pssm_diff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute KL divergence between two PSSMs — pssm_diff","text":"","code":"if (FALSE) { # \\dontrun{ res1 <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1]) pssm_diff(res1$pssm, JASPAR_motifs[JASPAR_motifs$motif == \"HNF1A\", ]) } # }"},{"path":"/reference/pssm_match.html","id":null,"dir":"Reference","previous_headings":"","what":"Match PSSM to a directory of motifs — pssm_match","title":"Match PSSM to a directory of motifs — pssm_match","text":"Match PSSM directory motifs. PSSM matched motif directory computing correlation two PSSMs.","code":""},{"path":"/reference/pssm_match.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match PSSM to a directory of motifs — pssm_match","text":"","code":"pssm_match(   pssm,   motifs,   best = FALSE,   method = \"spearman\",   parallel = getOption(\"prego.parallel\", TRUE) )"},{"path":"/reference/pssm_match.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match PSSM to a directory of motifs — pssm_match","text":"pssm PSSM matrix data frame motifs data frame PSSMs ('', 'C', 'G' 'T' columns), additional column 'motif' containing motif name best return best match method method use computing correlation. See cor details. parallel use parallel processing. Set number cores using set_parallel.","code":""},{"path":"/reference/pssm_match.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match PSSM to a directory of motifs — pssm_match","text":"best TRUE, string best match. Otherwise, data frame row per motif column named 'cor' correlation pssm. data frame sorted descreasing correlation.","code":""},{"path":"/reference/pssm_match.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Match PSSM to a directory of motifs — pssm_match","text":"","code":"if (FALSE) { # \\dontrun{ res1 <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1]) head(pssm_match(res1$pssm, JASPAR_motifs)) pssm_match(res1$pssm, JASPAR_motifs, best = TRUE) } # }"},{"path":"/reference/pssm_rc.html","id":null,"dir":"Reference","previous_headings":"","what":"Reverse complement a PSSM — pssm_rc","title":"Reverse complement a PSSM — pssm_rc","text":"Reverse complement PSSM","code":""},{"path":"/reference/pssm_rc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reverse complement a PSSM — pssm_rc","text":"","code":"pssm_rc(pssm)"},{"path":"/reference/pssm_rc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reverse complement a PSSM — pssm_rc","text":"pssm PSSM. Data frame columns '', 'C', 'G', 'T' 'pos' matrix columns '', 'C', 'G', 'T'","code":""},{"path":"/reference/pssm_rc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reverse complement a PSSM — pssm_rc","text":"PSSM format, reverse complemented.","code":""},{"path":"/reference/pssm_rc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reverse complement a PSSM — pssm_rc","text":"","code":"# Create simulated PSSM data frame pssm <- data.frame(     pos = 1:4,     A = c(0.1, 0.2, 0.3, 0.1),     C = c(0.1, 0.3, 0.2, 0.1),     G = c(0.1, 0.3, 0.3, 0.7),     T = c(0.7, 0.2, 0.2, 0.1) )  # Reverse complement the PSSM rc_pssm <- pssm_rc(pssm)"},{"path":"/reference/pssm_to_kmer.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform PSSM (Position-Specific Scoring Matrix) to a KMER — pssm_to_kmer","title":"Transform PSSM (Position-Specific Scoring Matrix) to a KMER — pssm_to_kmer","text":"function transforms PSSM k-mer given length.","code":""},{"path":"/reference/pssm_to_kmer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform PSSM (Position-Specific Scoring Matrix) to a KMER — pssm_to_kmer","text":"","code":"pssm_to_kmer(pssm, kmer_length = NULL, pos_bits_thresh = NULL, prior = 0.01)"},{"path":"/reference/pssm_to_kmer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform PSSM (Position-Specific Scoring Matrix) to a KMER — pssm_to_kmer","text":"pssm PSSM matrix data frame. PSSM must least kmer_length rows. kmer_length length k-mer return. NULL - length k-mer equal number rows PSSM. pos_bits_thresh numeric value indicating minimum number bits per position include nucleotide k-mer. nucleotide meet threshold, replaced 'N'. Default NULL. prior numeric value indicating prior probability nucleotide. Default 0.01.","code":""},{"path":"/reference/pssm_to_kmer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform PSSM (Position-Specific Scoring Matrix) to a KMER — pssm_to_kmer","text":"character vector length 1 containing k-mer.","code":""},{"path":"/reference/pssm_to_kmer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform PSSM (Position-Specific Scoring Matrix) to a KMER — pssm_to_kmer","text":"","code":"pssm_to_kmer(get_motif_pssm(\"HOMER.AP_1\")) #> [1] \"ATGACTCATC\" plot_pssm_logo_dataset(\"HOMER.AP_1\")"},{"path":"/reference/rc.html","id":null,"dir":"Reference","previous_headings":"","what":"Reverse Complement DNA Sequences — rc","title":"Reverse Complement DNA Sequences — rc","text":"function takes character vector DNA sequences returns reverse complements. uses efficient C++ implementation via Rcpp improved performance.","code":""},{"path":"/reference/rc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reverse Complement DNA Sequences — rc","text":"","code":"rc(dna)"},{"path":"/reference/rc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reverse Complement DNA Sequences — rc","text":"dna character vector DNA sequences. Can single sequence multiple sequences. sequences can upper lower case.","code":""},{"path":"/reference/rc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reverse Complement DNA Sequences — rc","text":"character vector length input, element reverse complement corresponding input sequence.","code":""},{"path":"/reference/rc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reverse Complement DNA Sequences — rc","text":"function performs following operations sequence: 1. Converts sequence uppercase. 2. Reverses sequence. 3. Complements base (<->T, C<->G). Non-standard characters (, T, C, G) preserved reversed positions.","code":""},{"path":"/reference/rc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reverse Complement DNA Sequences — rc","text":"","code":"rc(\"ATCG\") # Returns \"CGAT\" #> [1] \"CGAT\" rc(c(\"ATCG\", \"GGCC\", \"TATA\")) # Returns c(\"CGAT\", \"GGCC\", \"TATA\") #> [1] \"CGAT\" \"GGCC\" \"TATA\""},{"path":"/reference/regress_pwm.clusters.html","id":null,"dir":"Reference","previous_headings":"","what":"Run PWM regression on clusters — regress_pwm.clusters","title":"Run PWM regression on clusters — regress_pwm.clusters","text":"Run PWM regression clusters","code":""},{"path":"/reference/regress_pwm.clusters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run PWM regression on clusters — regress_pwm.clusters","text":"","code":"regress_pwm.clusters(   sequences,   clusters,   use_sample = TRUE,   match_with_db = TRUE,   screen_db = FALSE,   sample_frac = NULL,   sample_ratio = 1,   final_metric = \"ks\",   parallel = getOption(\"prego.parallel\", TRUE),   use_sge = FALSE,   dataset = all_motif_datasets(),   motifs = NULL,   min_D = 0,   prior = 0.01,   alternative = \"two.sided\",   ... )"},{"path":"/reference/regress_pwm.clusters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run PWM regression on clusters — regress_pwm.clusters","text":"sequences vector DNA sequences ('', 'T', 'C' 'G'. go toupper). Please make sure sequences long enough cover spat_num_bins * spat_bin_size bp, centered around motif/signal. clusters vector cluster assignments sequence use_sample whether use sampled optimization (default: FALSE). match_with_db match resulting PWMs motif databases using pssm_match. add column named 'db_match' stats data frame, together 'pred_mat_db' database motif predictions, 'db_dataset' similar 'motif_dataset' database motifs. Note closest match returned, even similar enough absolute terms. Also, match done resulting regression pssm pssms database - order find best motif database set screen_db=TRUE. screen_db screen best motif database explains clusters. See screen_pwm.clusters. sample_frac vector two numbers, specifying fraction sequences use sampling sequences cluster (first number) cluster (second number). NULL - sample_ratio sample_frac NULL, number sequences cluster equal sample_ratio times number sequences cluster. final_metric metric use order choose best motif. One 'ks' 'r2'. Note unlike score_metric used regression , metric used choosing best motif runs sampled dataset. NULL - 'ks' used binary response 'r2' continuous response. parallel whether run optimization parallel. use set_parallel set number cores use. use_sge use function gcluster.run2 misha.ext package run optimization SGE cluster. relevant misha.ext package installed. Note gcluster.run2 writes current environment starting parallelization, better run function clean environment. Also, Note 'prego' needs installed order work, .e. use devtools::load_all() pkgload::load_all() load package. dataset data frame PSSMs ('', 'C', 'G' 'T' columns), additional column 'motif' containing motif name, example HOMER_motifs JASPAR_motifs, all_motif_datasets(), MotifDB object. motifs names specific motifs extract dataset min_D minimum distance consider match prior prior probability nucleotide. alternative alternative hypothesis KS test. Can \"two.sided\", \"less\" \"greater\" ... Arguments passed regress_pwm, regress_pwm.sample response matrix response variables - number rows equal number sequences motif Initial motif start regression . Can either string kmer character \"*\" indicates wildcard data frame pre-computed PSSM (see slot pssm return value function). NULL - K-mer screen performed order find best kmer initialization. init_from_dataset TRUE, regression initialized PSSM best motif dataset. init_from_dataset initialize regression PSSM best motif motif_dataset, using final_metric metric. TRUE, motif parameter ignored. See screen_pwm details. motif_length Length seed motif. motif shorter , extended wildcards (stars). Note motif longer , truncated. score_metric metric use optimizing PWM. One \"r2\" \"ks\". using \"ks\" response variable single vector 0 1. bidirect motif bi-directional. TRUE, reverse-complement motif used well. spat_bin_size size spatial bin (bp). spat_num_bins number spatial bins. Please make sure sequences long enough cover number bins. bp outside spat_bin_size * spat_num_bins ignored. bidirect TRUE, number bins odd 'prego' symmetrizes motif around center bin. spat_model previously computed spatial model (see spat) return value function. improve_epsilon minimum improve objective function continue optimization min_nuc_prob minimum nucleotide probability every iteration unif_prior uniform prior nucleotide probabilities include_response include response resulting list (default: TRUE) verbose show verbose messages. seed random seed consensus_single_thresh,consensus_double_thresh thresholds consensus sequence calculation (single double nucleotides) motif_dataset data frame PSSMs ('', 'C', 'G' 'T' columns), additional column 'motif' containing motif name, example HOMER_motifs, JASPAR_motifs all_motif_datasets(). default all_motif_datasets() used. multi_kmers TRUE, different candidates kmers regressed order find best seed according final_metric. kmer_length vector kmer lengths screen order find best seed motif. max_cands maximum number kmer candidates try. motif_num Number motifs infer. motif_num > 1, function run motif_num times, time residuals linear model previous runs (see smooth_k parameter). best motif returned, others stored 'models' return value. smooth_k k smoothing predictions model order compute residuals motif_num > 1. residuals computed response - running mean size 'k' current model. min_kmer_cor minimal correlation kmer response order use seed. internal_num_folds number folds use internal cross-validation. sample_for_kmers Use random sample dataset order find best kmer. useful dataset large kmer screen take long time. Note final regression performed entire dataset. relevant multi_kmers TRUE. sample_idxs indices sequences use kmer screen. NULL, random sample used. log_energy transform energy log scale iteration. energy_func function transform energy iteration. accept numeric vector return numeric vector. e.g. log function(x) x^2. Note range input energies 0 1 (probability motif sequence), inferred function using returned energies (log scale) make sure function first log transforms using log_energy=TRUE. xmin,xmax,npts range energy function number points use interpolation. energy_func_generator function generate energy function regressing multiple motifs. accept result previous iteration + original response return function similar energy_func. e.g.  function(prev_reg, resp) {        df <- data.frame(x = prev_reg$pred, y = resp)        fn_gam <- .formula(\"y ~ s(x, k=3, bs='cr')\")        model <- mgcv::gam(fn_gam, family = binomial(link = \"logit\"), data = df, method=\"REML\")        function(z){            mgcv::predict.gam(object = model, newdata = data.frame(x = z)) }}. parameter NULL, energy_func_generator create energy function run another step regression initialized previous motif energy_func energy function. useful energy function monotonic, example - one might want use gam model fit energy function like example . optimize_pwm optimize PWM model (Default: TRUE). FALSE, PWM model used initial model spatial model. optimize_spat optimize spatial model (Default: TRUE). FALSE, spatial model used initial model PWM model. kmer_sequence_length length sequence use kmer screen. NULL, entire sequence used. symmetrize_spat TRUE, spatial model symmetrized around center bin. Default: TRUE. min_gap,max_gap length gap considered pattern. one gap, length min_gap:max_gap, used, located anywhere motif. Note greatly expand search space (increase multiple testing severely).","code":""},{"path":"/reference/regress_pwm.clusters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run PWM regression on clusters — regress_pwm.clusters","text":"list following elements: models: list models cluster cluster_mat: indicator matrix cluster assignments pred_mat: matrix energies predicted motifs per cluster (columns) sequence (rows) motif_dataset: data frame PSSMs cluster spat_dataset: data frame spatial model cluster stats: data frame statistics cluster","code":""},{"path":"/reference/regress_pwm.clusters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run PWM regression on clusters — regress_pwm.clusters","text":"","code":"if (FALSE) { # \\dontrun{ res <- regress_pwm.clusters(cluster_sequences_example, clusters_example) head(res$pred_mat) res$stats  plot_regression_qc(res$models[[1]], title = names(res$models)[1])  # multiple motifs per cluster res_multi <- regress_pwm.clusters(cluster_sequences_example, clusters_example, motif_num = 3) res_multi$multi_stats plot_regression_qc_multi(res_multi$models[[1]], title = names(res_multi$models)[1]) } # }  # screen also for the best motif in the database res_screen <- regress_pwm.clusters(cluster_sequences_example, clusters_example, screen_db = TRUE) #> ℹ Using sampled optimization #> ℹ Running regression for 5 clusters #> ℹ Matching with motif databases #> ℹ Screening motif databases for 5 clusters res_screen$stats #> # A tibble: 5 x 9 #>   cluster consensus      ks_D        r2      seed_motif #> 1    c100  WGA***AT 0.6530423 0.3224333 ***TGAT*GATG*** #> 2    c111    Y*RTAA 0.8413087 0.5127852 ***CAATTAAC**** #> 3     c29 T*A***W*Y 0.8219863 0.5360583 ***TTAA*CATT*** #> 4      c5      <NA> 0.5633821 0.1974345 ***AATCA*TAA*** #> 5      c6       ATC 0.5971442 0.2654848 ***TA*CTTATC*** #>                        db_match db_match_cor   ks_D_db #> 1 HOCOMOCO.PDX1_HUMAN.H11MO.0.A    0.7996138 0.6337245 #> 2           JOLMA.CDX2_mono_DBD    0.8912204 0.7803839 #> 3          JASPAR.RFX1.MA0365.1    0.7338186 0.8606183 #> 4        JOLMA.NKX6-1_mono_full    0.6767482 0.5793942 #> 5                  JASPAR.GATA2    0.7807456 0.5790557 #>                         db_motif #> 1                    HOMER.HOXA2 #> 2                    JASPAR.CDX1 #> 3 HOCOMOCO.HNF1B_HUMAN.H11MO.0.A #> 4                    HOMER.Gata2 #> 5                   JASPAR.GATA5  plot_regression_qc(res_screen$models[[1]], title = names(res_screen$models)[1]) #> Warning: All aesthetics have length 1, but the data has 2359 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing a #>   single row."},{"path":"/reference/regress_pwm.cv.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validate a PWM regression model — regress_pwm.cv","title":"Cross-validate a PWM regression model — regress_pwm.cv","text":"Perform cross-validation PWM regression model. can either provide explicit folds, use nfolds argument set number folds. response binary (0 1) categories vector given, folds stratified response/categories.","code":""},{"path":"/reference/regress_pwm.cv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validate a PWM regression model — regress_pwm.cv","text":"","code":"regress_pwm.cv(   sequences,   response,   nfolds = NULL,   metric = NULL,   folds = NULL,   categories = NULL,   use_sample = FALSE,   seed = 60427,   parallel = getOption(\"prego.parallel\", FALSE),   fold_parallel = !parallel && getOption(\"prego.parallel\", FALSE),   add_full_model = TRUE,   alternative = \"less\",   ... )"},{"path":"/reference/regress_pwm.cv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validate a PWM regression model — regress_pwm.cv","text":"sequences vector DNA sequences ('', 'T', 'C' 'G'. go toupper). Please make sure sequences long enough cover spat_num_bins * spat_bin_size bp, centered around motif/signal. response matrix response variables - number rows equal number sequences nfolds number folds cross-validation. Can NULL folds provided. metric metric use cross-validation. One 'ks' 'r2'. NULL - 'ks' set binary response 'r2' continuous response. folds vector fold numbers sequence (optional) categories vector categories sequence (optional) use_sample whether use sampled optimization . seed random seed parallel whether run cross-validation parallel. fold_parallel whether run optimization fold parallel. recommended set FALSE parallel TRUE. add_full_model whether add full model (without cross-validation) results. alternative alternative hypothesis p-value calculation using ks.test. One \"two.sided\", \"less\" \"greater\". ... Arguments passed regress_pwm, regress_pwm.sample motif Initial motif start regression . Can either string kmer character \"*\" indicates wildcard data frame pre-computed PSSM (see slot pssm return value function). NULL - K-mer screen performed order find best kmer initialization. init_from_dataset TRUE, regression initialized PSSM best motif dataset. init_from_dataset initialize regression PSSM best motif motif_dataset, using final_metric metric. TRUE, motif parameter ignored. See screen_pwm details. motif_length Length seed motif. motif shorter , extended wildcards (stars). Note motif longer , truncated. score_metric metric use optimizing PWM. One \"r2\" \"ks\". using \"ks\" response variable single vector 0 1. bidirect motif bi-directional. TRUE, reverse-complement motif used well. spat_bin_size size spatial bin (bp). spat_num_bins number spatial bins. Please make sure sequences long enough cover number bins. bp outside spat_bin_size * spat_num_bins ignored. bidirect TRUE, number bins odd 'prego' symmetrizes motif around center bin. spat_model previously computed spatial model (see spat) return value function. improve_epsilon minimum improve objective function continue optimization min_nuc_prob minimum nucleotide probability every iteration unif_prior uniform prior nucleotide probabilities include_response include response resulting list (default: TRUE) verbose show verbose messages. consensus_single_thresh,consensus_double_thresh thresholds consensus sequence calculation (single double nucleotides) match_with_db match resulting PWMs motif databases using pssm_match. Note closest match returned, even similar enough absolute terms. screen_db Screen motif_dataset using screen_pwm use best motif initial motif. TRUE, following fields added return value: \"db_motif\", \"db_motif_pred\", \"db_motif_pssm\" \"db_motif_score\". motif_dataset data frame PSSMs ('', 'C', 'G' 'T' columns), additional column 'motif' containing motif name, example HOMER_motifs, JASPAR_motifs all_motif_datasets(). default all_motif_datasets() used. multi_kmers TRUE, different candidates kmers regressed order find best seed according final_metric. final_metric metric use order choose best motif. One 'ks' 'r2'. Note unlike score_metric used regression , metric used choosing best motif runs sampled dataset. NULL - 'ks' used binary response 'r2' continuous response. kmer_length vector kmer lengths screen order find best seed motif. max_cands maximum number kmer candidates try. motif_num Number motifs infer. motif_num > 1, function run motif_num times, time residuals linear model previous runs (see smooth_k parameter). best motif returned, others stored 'models' return value. smooth_k k smoothing predictions model order compute residuals motif_num > 1. residuals computed response - running mean size 'k' current model. min_kmer_cor minimal correlation kmer response order use seed. internal_num_folds number folds use internal cross-validation. sample_for_kmers Use random sample dataset order find best kmer. useful dataset large kmer screen take long time. Note final regression performed entire dataset. relevant multi_kmers TRUE. sample_frac fraction dataset use kmer screen. Default: 0.1. sample_idxs indices sequences use kmer screen. NULL, random sample used. sample_ratio ratio '1' category '0' category sampled dataset (binary response). Relevant sample_frac NULL. log_energy transform energy log scale iteration. energy_func function transform energy iteration. accept numeric vector return numeric vector. e.g. log function(x) x^2. Note range input energies 0 1 (probability motif sequence), inferred function using returned energies (log scale) make sure function first log transforms using log_energy=TRUE. xmin,xmax,npts range energy function number points use interpolation. energy_func_generator function generate energy function regressing multiple motifs. accept result previous iteration + original response return function similar energy_func. e.g.  function(prev_reg, resp) {        df <- data.frame(x = prev_reg$pred, y = resp)        fn_gam <- .formula(\"y ~ s(x, k=3, bs='cr')\")        model <- mgcv::gam(fn_gam, family = binomial(link = \"logit\"), data = df, method=\"REML\")        function(z){            mgcv::predict.gam(object = model, newdata = data.frame(x = z)) }}. parameter NULL, energy_func_generator create energy function run another step regression initialized previous motif energy_func energy function. useful energy function monotonic, example - one might want use gam model fit energy function like example . optimize_pwm optimize PWM model (Default: TRUE). FALSE, PWM model used initial model spatial model. optimize_spat optimize spatial model (Default: TRUE). FALSE, spatial model used initial model PWM model. kmer_sequence_length length sequence use kmer screen. NULL, entire sequence used. symmetrize_spat TRUE, spatial model symmetrized around center bin. Default: TRUE. min_gap,max_gap length gap considered pattern. one gap, length min_gap:max_gap, used, located anywhere motif. Note greatly expand search space (increase multiple testing severely).","code":""},{"path":"/reference/regress_pwm.cv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-validate a PWM regression model — regress_pwm.cv","text":"list following elements: cv_models: list models, one fold. cv_pred: vector predictions sequence. score: score model cross-validated predictions. cv_scores: vector scores fold. folds: vector fold number sequence. full_model: full model (without cross-validation), add_full_model TRUE.","code":""},{"path":"/reference/regress_pwm.cv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validate a PWM regression model — regress_pwm.cv","text":"","code":"if (FALSE) { # \\dontrun{ res <- regress_pwm.cv(     cluster_sequences_example, cluster_mat_example[, 1],     nfolds = 5, use_sample = TRUE, sample_frac = c(0.1, 1) ) res$score res$cv_scores  plot(     res$cv_pred,     res$full_model$pred,     xlab = \"CV predictions\", ylab = \"Full model predictions\", cex = 0.1 ) plot_regression_prediction_binary(res$cv_pred, cluster_mat_example[, 1]) plot_regression_prediction_binary(res$full_model$pred, cluster_mat_example[, 1])  # without sampling res <- regress_pwm.cv(     cluster_sequences_example, cluster_mat_example[, 1],     nfolds = 5, use_sample = FALSE ) res$score res$cv_scores plot(res$cv_pred,     res$full_model$pred,     xlab = \"CV predictions\", ylab = \"Full model predictions\", cex = 0.1 ) } # }"},{"path":"/reference/regress_pwm.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform a PWM regression — regress_multiple_motifs","title":"Perform a PWM regression — regress_multiple_motifs","text":"Perform PWM regression","code":""},{"path":"/reference/regress_pwm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform a PWM regression — regress_multiple_motifs","text":"","code":"regress_multiple_motifs(   sequences,   response,   motif = NULL,   motif_length = 15,   score_metric = \"r2\",   bidirect = TRUE,   spat_bin_size = NULL,   spat_num_bins = NULL,   spat_model = NULL,   improve_epsilon = 0.0001,   min_nuc_prob = 0.001,   unif_prior = 0.05,   include_response = TRUE,   seed = 60427,   verbose = FALSE,   kmer_length = 8,   multi_kmers = FALSE,   final_metric = NULL,   max_cands = 10,   min_gap = 0,   max_gap = 1,   min_kmer_cor = 0.08,   motif_num = 2,   smooth_k = 100,   consensus_single_thresh = 0.6,   consensus_double_thresh = 0.85,   internal_num_folds = 1,   match_with_db = TRUE,   motif_dataset = all_motif_datasets(),   parallel = getOption(\"prego.parallel\", FALSE),   alternative = \"less\",   sample_for_kmers = FALSE,   sample_frac = NULL,   sample_idxs = NULL,   sample_ratio = 1,   log_energy = FALSE,   energy_func_generator = NULL,   energy_func = NULL,   optimize_pwm = TRUE,   optimize_spat = TRUE,   ... )  regress_pwm(   sequences,   response,   motif = NULL,   motif_length = 15,   init_from_dataset = FALSE,   score_metric = \"r2\",   bidirect = TRUE,   spat_bin_size = NULL,   spat_num_bins = NULL,   spat_model = NULL,   improve_epsilon = 0.0001,   min_nuc_prob = 0.001,   unif_prior = 0.05,   include_response = TRUE,   seed = 60427,   verbose = FALSE,   kmer_length = 8,   multi_kmers = TRUE,   final_metric = NULL,   max_cands = 10,   min_gap = 0,   max_gap = 1,   min_kmer_cor = 0.08,   motif_num = 1,   smooth_k = 100,   consensus_single_thresh = 0.6,   consensus_double_thresh = 0.85,   internal_num_folds = 1,   match_with_db = TRUE,   screen_db = FALSE,   motif_dataset = all_motif_datasets(),   parallel = getOption(\"prego.parallel\", FALSE),   alternative = \"less\",   sample_for_kmers = FALSE,   sample_frac = NULL,   sample_idxs = NULL,   sample_ratio = 1,   log_energy = FALSE,   energy_func = NULL,   xmin = -100,   xmax = 100,   npts = 10000,   energy_func_generator = NULL,   optimize_pwm = TRUE,   optimize_spat = TRUE,   kmer_sequence_length = NULL,   symmetrize_spat = TRUE,   ... )"},{"path":"/reference/regress_pwm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform a PWM regression — regress_multiple_motifs","text":"sequences vector DNA sequences ('', 'T', 'C' 'G'. go toupper). Please make sure sequences long enough cover spat_num_bins * spat_bin_size bp, centered around motif/signal. response matrix response variables - number rows equal number sequences motif Initial motif start regression . Can either string kmer character \"*\" indicates wildcard data frame pre-computed PSSM (see slot pssm return value function). NULL - K-mer screen performed order find best kmer initialization. init_from_dataset TRUE, regression initialized PSSM best motif dataset. motif_length Length seed motif. motif shorter , extended wildcards (stars). Note motif longer , truncated. score_metric metric use optimizing PWM. One \"r2\" \"ks\". using \"ks\" response variable single vector 0 1. bidirect motif bi-directional. TRUE, reverse-complement motif used well. spat_bin_size size spatial bin (bp). spat_num_bins number spatial bins. Please make sure sequences long enough cover number bins. bp outside spat_bin_size * spat_num_bins ignored. bidirect TRUE, number bins odd 'prego' symmetrizes motif around center bin. spat_model previously computed spatial model (see spat) return value function. improve_epsilon minimum improve objective function continue optimization min_nuc_prob minimum nucleotide probability every iteration unif_prior uniform prior nucleotide probabilities include_response include response resulting list (default: TRUE) seed random seed verbose show verbose messages. kmer_length vector kmer lengths screen order find best seed motif. multi_kmers TRUE, different candidates kmers regressed order find best seed according final_metric. final_metric metric use order choose best motif. One 'ks' 'r2'. Note unlike score_metric used regression , metric used choosing best motif runs sampled dataset. NULL - 'ks' used binary response 'r2' continuous response. max_cands maximum number kmer candidates try. min_gap, max_gap length gap considered pattern. one gap, length min_gap:max_gap, used, located anywhere motif. Note greatly expand search space (increase multiple testing severely). min_kmer_cor minimal correlation kmer response order use seed. motif_num Number motifs infer. motif_num > 1, function run motif_num times, time residuals linear model previous runs (see smooth_k parameter). best motif returned, others stored 'models' return value. smooth_k k smoothing predictions model order compute residuals motif_num > 1. residuals computed response - running mean size 'k' current model. consensus_single_thresh, consensus_double_thresh thresholds consensus sequence calculation (single double nucleotides) internal_num_folds number folds use internal cross-validation. match_with_db match resulting PWMs motif databases using pssm_match. Note closest match returned, even similar enough absolute terms. motif_dataset data frame PSSMs ('', 'C', 'G' 'T' columns), additional column 'motif' containing motif name, example HOMER_motifs, JASPAR_motifs all_motif_datasets(). default all_motif_datasets() used. parallel whether run optimization parallel. use set_parallel set number cores use. alternative alternative hypothesis p-value calculation using ks.test. One \"two.sided\", \"less\" \"greater\". sample_for_kmers Use random sample dataset order find best kmer. useful dataset large kmer screen take long time. Note final regression performed entire dataset. relevant multi_kmers TRUE. sample_frac fraction dataset use kmer screen. Default: 0.1. sample_idxs indices sequences use kmer screen. NULL, random sample used. sample_ratio ratio '1' category '0' category sampled dataset (binary response). Relevant sample_frac NULL. log_energy transform energy log scale iteration. energy_func_generator function generate energy function regressing multiple motifs. accept result previous iteration + original response return function similar energy_func. e.g.  function(prev_reg, resp) {        df <- data.frame(x = prev_reg$pred, y = resp)        fn_gam <- .formula(\"y ~ s(x, k=3, bs='cr')\")        model <- mgcv::gam(fn_gam, family = binomial(link = \"logit\"), data = df, method=\"REML\")        function(z){            mgcv::predict.gam(object = model, newdata = data.frame(x = z)) }}. parameter NULL, energy_func_generator create energy function run another step regression initialized previous motif energy_func energy function. useful energy function monotonic, example - one might want use gam model fit energy function like example . energy_func function transform energy iteration. accept numeric vector return numeric vector. e.g. log function(x) x^2. Note range input energies 0 1 (probability motif sequence), inferred function using returned energies (log scale) make sure function first log transforms using log_energy=TRUE. optimize_pwm optimize PWM model (Default: TRUE). FALSE, PWM model used initial model spatial model. optimize_spat optimize spatial model (Default: TRUE). FALSE, spatial model used initial model PWM model. ... Arguments passed screen_kmers min_cor patterns maximum correlation one response variable larger min_cor reported is_train boolean vector determine subset sequences use screening min_gap,max_gap length gap considered pattern. one gap, length min_gap:max_gap, used, located anywhere motif. Note greatly expand search space (increase multiple testing severely). from_range Sequences considered position from_range (default 0) to_range Sequences considered position to_range (default NULL - using length sequences) return_mat Return matrix patterns correlation response variables instead data frame. (default: FALSE) init_from_dataset initialize regression PSSM best motif motif_dataset, using final_metric metric. TRUE, motif parameter ignored. See screen_pwm details. screen_db Screen motif_dataset using screen_pwm use best motif initial motif. TRUE, following fields added return value: \"db_motif\", \"db_motif_pred\", \"db_motif_pssm\" \"db_motif_score\". xmin, xmax, npts range energy function number points use interpolation. kmer_sequence_length length sequence use kmer screen. NULL, entire sequence used. symmetrize_spat TRUE, spatial model symmetrized around center bin. Default: TRUE.","code":""},{"path":"/reference/regress_pwm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform a PWM regression — regress_multiple_motifs","text":"list following elements: pssm: data frame pssm matrix inferred motif, rows positions columns nucleotides. spat: data frame inferred spatial model, spatial factor bin. pred: vector predicted pwm sequence. consensus: Consensus sequence based PSSM. response: response matrix. include_response FALSE, response matrix included list. r2: \\(r^2\\) prediction respect response variable. ks: response binary, Kolmogorov-Smirnov test results predictions response 1 vs predictions response 0. seed_motif: seed motif started regression. kmers: k-mers screened order find best seed motif (motif NULL). sample_idxs: indices sequences used regression (regress_pwm.sample). predict: function can used predict PWM new sequence. match_with_db TRUE, following additional elements returned: motif_db: motif database similar resulting PSSM. db_match_cor: correlation resulting PSSM closest match motif database. db_match_pssm: PSSM closest match motif database. db_match_pred: predicted PWM closest match motif database. db_match_r2: \\(r^2\\) predicted PWM closest match motif database response db_match_ks: response binary, Kolmogorov-Smirnov test results predicted PWM closest match motif database response 1 vs predictions response 0. screen_db TRUE, following additional elements returned: db_motif: best motif motif database. db_motif_pred: predicted PWM best motif motif database. db_motif_pssm: PSSM best motif motif database. db_motif_score: score best motif motif database. n_motifs greater 1, list following elements returned: models: list () inferred model multi_stats: data frame following columns: model, score (KS binary, r^2 otherwise), comb_score (score combined linear model models 1:) additional statistics per model pred: vector predicted pwm using linear model combined scores. comb_modle: linear model combined scores. predict: function can used predict PWM new sequence. predict_multi: function can used predict PWM different models new sequence","code":""},{"path":"/reference/regress_pwm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform a PWM regression — regress_multiple_motifs","text":"","code":"if (FALSE) { # \\dontrun{ res <- regress_pwm(sequences_example, response_mat_example) res$pssm res$spat head(res$pred)  plot_regression_qc(res)  # intialize with a pre-computed PSSM res1 <- regress_pwm(sequences_example, response_mat_example, motif = res$pssm)  # intialize with a pre-computed PSSM and spatial model res2 <- regress_pwm(     sequences_example,     response_mat_example,     motif = res$pssm,     spat_model = res$spat )  # binary response res_binary <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1]) plot_regression_qc(res_binary)  # match with db res_binary <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1], match_with_db = TRUE) plot_regression_qc(res_binary)  # Screen for best db motif res_binary <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1], screen_db = TRUE) plot_regression_qc(res_binary)  # initialize with a motif from the database res_binary <- regress_pwm(     cluster_sequences_example,     cluster_mat_example[, 1],     init_from_dataset = TRUE )  # use multiple kmer seeds res_multi <- regress_pwm(     cluster_sequences_example,     cluster_mat_example[, 1],     multi_kmers = TRUE,     kmer_length = 6:8,     final_metric = \"ks\" ) plot_regression_qc(res_multi)  # Screen for multiple motifs res_multi <- regress_pwm(     cluster_sequences_example,     cluster_mat_example[, 1],     motif_num = 3,     match_with_db = TRUE ) res_multi$multi_stats plot_regression_qc_multi(res_multi) } # }  # regress_multiple_motifs is an alias for regress_pwm with motif_num > 1 res_multi2 <- regress_multiple_motifs(     cluster_sequences_example,     cluster_mat_example[, 1],     motif_num = 5,     match_with_db = TRUE ) #> ℹ Using 7 bins of size 40 bp #> ℹ Running regression for 5 motifs #>  #> ── Running first regression ── #>  #> ℹ Using 7 bins of size 40 bp #> ℹ Using \"ks\" as the final metric #> ℹ Number of response variables: 1 #> ℹ Screening for kmers in order to initialize regression #> ℹ Number of response variables: 1 #> ℹ Screening kmers of length 8, from position 0 to position 300 #> ℹ Gaps of length 0:1 are allowed #> ℹ minimal correlation: 0.08 #> ✔ Found 1032 kmers in 2359 sequences. #> ℹ Motif is shorter than 15, extending with wildcards #> ℹ Initializing regression with the following motif: \"***TTAAT*ATT***\" #> ℹ Running regression #> • Motif length: 15 #> • Bidirectional: TRUE #> • Spat min: 10 #> • Spat max: 290 #> • Spat bin size: 40 #> • Number of bins: 7 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> ✔ Finished running regression. Consensus: \"T*AM**W*Y\" #> ℹ Best match in the database: \"JOLMA.HNF1B_di_full_1\", cor: 0.784 #> ✔ \"JOLMA.HNF1B_di_full_1\" KS test D: 0.8487, p-value: 0 #> ✔ KS test D: 0.8472, p-value: 0 #>  #> ── Running regression #2 ── #>  #> ℹ Using 7 bins of size 40 bp #> ℹ Using \"r2\" as the final metric #> ℹ Number of response variables: 1 #> ℹ Screening for kmers in order to initialize regression #> ℹ Number of response variables: 1 #> ℹ Screening kmers of length 8, from position 0 to position 300 #> ℹ Gaps of length 0:1 are allowed #> ℹ minimal correlation: 0.08 #> ✔ Found 2525 kmers in 2359 sequences. #> ℹ Motif is shorter than 15, extending with wildcards #> ℹ Initializing regression with the following motif: \"***TAATGC*TA***\" #> ℹ Running regression #> • Motif length: 15 #> • Bidirectional: TRUE #> • Spat min: 10 #> • Spat max: 290 #> • Spat bin size: 40 #> • Number of bins: 7 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> ✔ Finished running regression. Consensus: \"TTAATGS*TA*T\" #> ℹ Best match in the database: \"JOLMA.SOX9_mono_DBD\", cor: 0.685 #> ✔ R^2: 0.0055 #> ℹ KS statistic: 0.395846125038647 #> ℹ KS test statistic for models 1 and 2: 0.85079972652967 #> ℹ Improvement in KS test statistic: 0.00363937624378918 #>  #> ── Running regression #3 ── #>  #> ℹ Using 7 bins of size 40 bp #> ℹ Using \"r2\" as the final metric #> ℹ Number of response variables: 1 #> ℹ Screening for kmers in order to initialize regression #> ℹ Number of response variables: 1 #> ℹ Screening kmers of length 8, from position 0 to position 300 #> ℹ Gaps of length 0:1 are allowed #> ℹ minimal correlation: 0.08 #> ✔ Found 2720 kmers in 2359 sequences. #> ℹ Motif is shorter than 15, extending with wildcards #> ℹ Initializing regression with the following motif: \"***AAG*GGTTG***\" #> ℹ Running regression #> • Motif length: 15 #> • Bidirectional: TRUE #> • Spat min: 10 #> • Spat max: 290 #> • Spat bin size: 40 #> • Number of bins: 7 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> ✔ Finished running regression. Consensus: \"T**AAA*GG*TG*A\" #> ℹ Best match in the database: \"JASPAR.MSN4\", cor: 0.676 #> ✔ R^2: 0.0354 #> ℹ KS statistic: 0.0200617485553538 #> ℹ KS test statistic for models 1, 2, and 3: 0.865892850144356 #> ℹ Improvement in KS test statistic: 0.0150931236146855 #>  #> ── Running regression #4 ── #>  #> ℹ Using 7 bins of size 40 bp #> ℹ Using \"r2\" as the final metric #> ℹ Number of response variables: 1 #> ℹ Screening for kmers in order to initialize regression #> ℹ Number of response variables: 1 #> ℹ Screening kmers of length 8, from position 0 to position 300 #> ℹ Gaps of length 0:1 are allowed #> ℹ minimal correlation: 0.08 #> ✔ Found 1679 kmers in 2359 sequences. #> ℹ Motif is shorter than 15, extending with wildcards #> ℹ Initializing regression with the following motif: \"***AGCG*AACC***\" #> ℹ Running regression #> • Motif length: 15 #> • Bidirectional: TRUE #> • Spat min: 10 #> • Spat max: 290 #> • Spat bin size: 40 #> • Number of bins: 7 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> ✔ Finished running regression. Consensus: \"GCG*AACCTAC\" #> ℹ Best match in the database: \"JASPAR.NAC025\", cor: 0.721 #> ✔ R^2: 0.0204 #> ℹ KS statistic: 0.112921908544206 #> ℹ KS test statistic for models 1, 2, 3, and 4: 0.874352794143903 #> ℹ Improvement in KS test statistic: 0.00845994399954719 #>  #> ── Running regression #5 ── #>  #> ℹ Using 7 bins of size 40 bp #> ℹ Using \"r2\" as the final metric #> ℹ Number of response variables: 1 #> ℹ Screening for kmers in order to initialize regression #> ℹ Number of response variables: 1 #> ℹ Screening kmers of length 8, from position 0 to position 300 #> ℹ Gaps of length 0:1 are allowed #> ℹ minimal correlation: 0.08 #> ✔ Found 1864 kmers in 2359 sequences. #> ℹ Motif is shorter than 15, extending with wildcards #> ℹ Initializing regression with the following motif: \"***AGCG*AACC***\" #> ℹ Running regression #> • Motif length: 15 #> • Bidirectional: TRUE #> • Spat min: 10 #> • Spat max: 290 #> • Spat bin size: 40 #> • Number of bins: 7 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> ✔ Finished running regression. Consensus: \"AGCG*AACCTA\" #> ℹ Best match in the database: \"JASPAR.ACE2\", cor: 0.642 #> ✔ R^2: 0.0101 #> ℹ KS statistic: 0.106887489603337 #> ℹ KS test statistic for models 1, 2, 3, 4, and 5: 0.880010538187867 #> ℹ Improvement in KS test statistic: 0.00565774404396424 #> ✔ Best model: model #1 (score of 0.847160350285881)"},{"path":"/reference/regress_pwm.sample.html","id":null,"dir":"Reference","previous_headings":"","what":"Run PWM regression on a sample of the data — regress_pwm.sample","title":"Run PWM regression on a sample of the data — regress_pwm.sample","text":"optimization performed sampled dataset size sample_frac, explicit sampled indices sample_idxs.","code":""},{"path":"/reference/regress_pwm.sample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run PWM regression on a sample of the data — regress_pwm.sample","text":"","code":"regress_pwm.sample(   sequences,   response,   spat_bin_size = NULL,   spat_num_bins = NULL,   bidirect = TRUE,   include_response = TRUE,   motif_num = 1,   multi_kmers = TRUE,   sample_frac = NULL,   sample_idxs = NULL,   sample_ratio = 1,   parallel = getOption(\"prego.parallel\", TRUE),   match_with_db = TRUE,   screen_db = FALSE,   motif_dataset = all_motif_datasets(),   seed = 60427,   final_metric = NULL,   unif_prior = 0.05,   alternative = \"two.sided\",   energy_func = NULL,   ... )"},{"path":"/reference/regress_pwm.sample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run PWM regression on a sample of the data — regress_pwm.sample","text":"sequences vector DNA sequences ('', 'T', 'C' 'G'. go toupper). Please make sure sequences long enough cover spat_num_bins * spat_bin_size bp, centered around motif/signal. response matrix response variables - number rows equal number sequences spat_bin_size size spatial bin (bp). spat_num_bins number spatial bins. Please make sure sequences long enough cover number bins. bp outside spat_bin_size * spat_num_bins ignored. bidirect TRUE, number bins odd 'prego' symmetrizes motif around center bin. bidirect motif bi-directional. TRUE, reverse-complement motif used well. include_response include response resulting list (default: TRUE) motif_num Number motifs infer. motif_num > 1, function run motif_num times, time residuals linear model previous runs (see smooth_k parameter). best motif returned, others stored 'models' return value. multi_kmers TRUE, different candidates kmers regressed order find best seed according final_metric. sample_frac fraction dataset sample. response categorical (0 1), sampling stratified category, .e. sample_frac can vector length 2 fraction 0 1 responses sample respectively. NULL - default 0.1 continuous variables, binary variables - number 0 responses equal sample_ratio times number 1 responses. sample_idxs indices sequences use. NULL, indices sampled using sample_frac. sample_ratio ratio '1' category '0' category sampled dataset. Relevant sample_frac NULL. parallel whether run optimization parallel. use set_parallel set number cores use. match_with_db match resulting PWMs motif databases using pssm_match. Note closest match returned, even similar enough absolute terms. screen_db Screen motif_dataset using screen_pwm use best motif initial motif. TRUE, following fields added return value: \"db_motif\", \"db_motif_pred\", \"db_motif_pssm\" \"db_motif_score\". motif_dataset data frame PSSMs ('', 'C', 'G' 'T' columns), additional column 'motif' containing motif name, example HOMER_motifs, JASPAR_motifs all_motif_datasets(). default all_motif_datasets() used. seed random seed final_metric metric use order choose best motif. One 'ks' 'r2'. Note unlike score_metric used regression , metric used choosing best motif runs sampled dataset. NULL - 'ks' used binary response 'r2' continuous response. unif_prior uniform prior nucleotide probabilities alternative alternative hypothesis p-value calculation using ks.test. One \"two.sided\", \"less\" \"greater\". energy_func function transform energy iteration. accept numeric vector return numeric vector. e.g. log function(x) x^2. Note range input energies 0 1 (probability motif sequence), inferred function using returned energies (log scale) make sure function first log transforms using log_energy=TRUE. ... Arguments passed regress_pwm, screen_kmers motif Initial motif start regression . Can either string kmer character \"*\" indicates wildcard data frame pre-computed PSSM (see slot pssm return value function). NULL - K-mer screen performed order find best kmer initialization. init_from_dataset TRUE, regression initialized PSSM best motif dataset. init_from_dataset initialize regression PSSM best motif motif_dataset, using final_metric metric. TRUE, motif parameter ignored. See screen_pwm details. motif_length Length seed motif. motif shorter , extended wildcards (stars). Note motif longer , truncated. score_metric metric use optimizing PWM. One \"r2\" \"ks\". using \"ks\" response variable single vector 0 1. spat_model previously computed spatial model (see spat) return value function. improve_epsilon minimum improve objective function continue optimization min_nuc_prob minimum nucleotide probability every iteration verbose show verbose messages. consensus_single_thresh,consensus_double_thresh thresholds consensus sequence calculation (single double nucleotides) kmer_length vector kmer lengths screen order find best seed motif. max_cands maximum number kmer candidates try. smooth_k k smoothing predictions model order compute residuals motif_num > 1. residuals computed response - running mean size 'k' current model. min_kmer_cor minimal correlation kmer response order use seed. internal_num_folds number folds use internal cross-validation. sample_for_kmers Use random sample dataset order find best kmer. useful dataset large kmer screen take long time. Note final regression performed entire dataset. relevant multi_kmers TRUE. log_energy transform energy log scale iteration. xmin,xmax,npts range energy function number points use interpolation. energy_func_generator function generate energy function regressing multiple motifs. accept result previous iteration + original response return function similar energy_func. e.g.  function(prev_reg, resp) {        df <- data.frame(x = prev_reg$pred, y = resp)        fn_gam <- .formula(\"y ~ s(x, k=3, bs='cr')\")        model <- mgcv::gam(fn_gam, family = binomial(link = \"logit\"), data = df, method=\"REML\")        function(z){            mgcv::predict.gam(object = model, newdata = data.frame(x = z)) }}. parameter NULL, energy_func_generator create energy function run another step regression initialized previous motif energy_func energy function. useful energy function monotonic, example - one might want use gam model fit energy function like example . optimize_pwm optimize PWM model (Default: TRUE). FALSE, PWM model used initial model spatial model. optimize_spat optimize spatial model (Default: TRUE). FALSE, spatial model used initial model PWM model. kmer_sequence_length length sequence use kmer screen. NULL, entire sequence used. symmetrize_spat TRUE, spatial model symmetrized around center bin. Default: TRUE. min_gap,max_gap length gap considered pattern. one gap, length min_gap:max_gap, used, located anywhere motif. Note greatly expand search space (increase multiple testing severely). min_cor patterns maximum correlation one response variable larger min_cor reported is_train boolean vector determine subset sequences use screening from_range Sequences considered position from_range (default 0) to_range Sequences considered position to_range (default NULL - using length sequences) return_mat Return matrix patterns correlation response variables instead data frame. (default: FALSE)","code":""},{"path":"/reference/regress_pwm.sample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run PWM regression on a sample of the data — regress_pwm.sample","text":"list following elements: pssm: data frame pssm matrix inferred motif, rows positions columns nucleotides. spat: data frame inferred spatial model, spatial factor bin. pred: vector predicted pwm sequence. consensus: Consensus sequence based PSSM. response: response matrix. include_response FALSE, response matrix included list. r2: \\(r^2\\) prediction respect response variable. ks: response binary, Kolmogorov-Smirnov test results predictions response 1 vs predictions response 0. seed_motif: seed motif started regression. kmers: k-mers screened order find best seed motif (motif NULL). sample_idxs: indices sequences used regression (regress_pwm.sample). predict: function can used predict PWM new sequence. match_with_db TRUE, following additional elements returned: motif_db: motif database similar resulting PSSM. db_match_cor: correlation resulting PSSM closest match motif database. db_match_pssm: PSSM closest match motif database. db_match_pred: predicted PWM closest match motif database. db_match_r2: \\(r^2\\) predicted PWM closest match motif database response db_match_ks: response binary, Kolmogorov-Smirnov test results predicted PWM closest match motif database response 1 vs predictions response 0. screen_db TRUE, following additional elements returned: db_motif: best motif motif database. db_motif_pred: predicted PWM best motif motif database. db_motif_pssm: PSSM best motif motif database. db_motif_score: score best motif motif database. n_motifs greater 1, list following elements returned: models: list () inferred model multi_stats: data frame following columns: model, score (KS binary, r^2 otherwise), comb_score (score combined linear model models 1:) additional statistics per model pred: vector predicted pwm using linear model combined scores. comb_modle: linear model combined scores. predict: function can used predict PWM new sequence. predict_multi: function can used predict PWM different models new sequence","code":""},{"path":"/reference/regress_pwm.sample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run PWM regression on a sample of the data — regress_pwm.sample","text":"","code":"if (FALSE) { # \\dontrun{ res <- regress_pwm.sample(     cluster_sequences_example,     cluster_mat_example[, 1],     final_metric = \"ks\",     screen_db = TRUE )  res$pssm res$spat head(res$pred)  plot_regression_qc(res) } # }"},{"path":"/reference/sample_quantile_matched_rows.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample rows respecting quantiles of a reference distribution — sample_quantile_matched_rows","title":"Sample rows respecting quantiles of a reference distribution — sample_quantile_matched_rows","text":"function randomly samples rows data frame way quantiles selected data match closely possible full data.","code":""},{"path":"/reference/sample_quantile_matched_rows.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample rows respecting quantiles of a reference distribution — sample_quantile_matched_rows","text":"","code":"sample_quantile_matched_rows(   data_frame,   reference,   sample_fraction,   num_quantiles = 10,   seed = 60427,   verbose = TRUE )"},{"path":"/reference/sample_quantile_matched_rows.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample rows respecting quantiles of a reference distribution — sample_quantile_matched_rows","text":"data_frame data frame sample rows. reference numeric vector length number rows data frame. sample_fraction fraction specifying proportion rows sample data frame. num_quantiles integer specifying number quantiles, default 10. seed integer specifying random seed use. verbose logical specifying whether print messages.","code":""},{"path":"/reference/sample_quantile_matched_rows.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample rows respecting quantiles of a reference distribution — sample_quantile_matched_rows","text":"data frame sampled rows.","code":""},{"path":"/reference/sample_quantile_matched_rows.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample rows respecting quantiles of a reference distribution — sample_quantile_matched_rows","text":"","code":"sampled <- sample_quantile_matched_rows(mtcars, mtcars$mpg, sample_fraction = 0.1) #> ✔ Sampled 3 rows from the data frame. plot(quantile(mtcars$mpg), quantile(sampled$mpg)) abline(0, 1)"},{"path":"/reference/screen_kmers.html","id":null,"dir":"Reference","previous_headings":"","what":"Screen for kmers — screen_kmers","title":"Screen for kmers — screen_kmers","text":"Screen kmers","code":""},{"path":"/reference/screen_kmers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Screen for kmers — screen_kmers","text":"","code":"screen_kmers(   sequences,   response,   kmer_length = 6,   min_cor = 0.08,   is_train = NULL,   min_gap = 0,   max_gap = 0,   from_range = 0,   to_range = NULL,   return_mat = FALSE,   seed = 60427,   verbose = FALSE )"},{"path":"/reference/screen_kmers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Screen for kmers — screen_kmers","text":"sequences vector DNA sequences ('', 'T', 'C' 'G'. go toupper) response matrix response variables - number rows equal number sequences kmer_length number non-gap characters motifs screened min_cor patterns maximum correlation one response variable larger min_cor reported is_train boolean vector determine subset sequences use screening min_gap, max_gap length gap considered pattern. one gap, length min_gap:max_gap, used, located anywhere motif. Note greatly expand search space (increase multiple testing severely). from_range Sequences considered position from_range (default 0) to_range Sequences considered position to_range (default NULL - using length sequences) return_mat Return matrix patterns correlation response variables instead data frame. (default: FALSE) seed random seed verbose show verbose messages","code":""},{"path":"/reference/screen_kmers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Screen for kmers — screen_kmers","text":"data frame following columns, together column response variable correlation kmers response variable: kmer: kmer pattern, \"*\" indicates wildcard max_r2: maximum R^2 one response variables avg_n: average number times kmer appears sequences avg_var: variance number times kmer appears sequences return_mat TRUE, matrix correlations response variables (rows kmers) returned instead data frame. kmer found, empty data frame returned.","code":""},{"path":"/reference/screen_kmers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Screen for kmers — screen_kmers","text":"","code":"kmers <- screen_kmers(sequences_example, response_mat_example) #> ℹ Number of response variables: 5 #> ℹ Screening kmers of length 6, from position 0 to position 300 #> ℹ minimal correlation: 0.08 #> ✔ Found 575 kmers in 1000 sequences. head(kmers) #>     kmer     max_r2 avg_n    avg_var          c1          c2         c3 #> 1 AGATAA 0.04998882 0.140 0.15240000 -0.01025383 -0.03046725 -0.2235818 #> 2 TTATCT 0.02975253 0.128 0.13761599  0.03136108  0.04927359 -0.1724892 #> 3 CTTATC 0.02680831 0.080 0.07960001  0.02861430  0.01967959 -0.1637324 #> 4 GGGGAG 0.02300140 0.243 0.28195098  0.04611732  0.02960520  0.1516621 #> 5 GGGCGG 0.02280306 0.062 0.06015600  0.06576437  0.02662074  0.1510068 #> 6 TAACTG 0.02215597 0.071 0.06995900 -0.01145993 -0.02249238 -0.1488488 #>             c4          c5 #> 1  0.004382457 -0.03498838 #> 2  0.035843253  0.02917432 #> 3  0.059437271  0.03772539 #> 4  0.044013925  0.03089626 #> 5  0.104473867  0.12732512 #> 6 -0.037136175 -0.01858661  kmers <- screen_kmers(sequences_example, response_mat_example, return_mat = TRUE) #> ℹ Number of response variables: 5 #> ℹ Screening kmers of length 6, from position 0 to position 300 #> ℹ minimal correlation: 0.08 #> ✔ Found 575 kmers in 1000 sequences. head(kmers) #>                 c1          c2         c3           c4          c5 #> AGATAA -0.01025383 -0.03046725 -0.2235818  0.004382457 -0.03498838 #> TTATCT  0.03136108  0.04927359 -0.1724892  0.035843253  0.02917432 #> CTTATC  0.02861430  0.01967959 -0.1637324  0.059437271  0.03772539 #> GGGGAG  0.04611732  0.02960520  0.1516621  0.044013925  0.03089626 #> GGGCGG  0.06576437  0.02662074  0.1510068  0.104473867  0.12732512 #> TAACTG -0.01145993 -0.02249238 -0.1488488 -0.037136175 -0.01858661  kmers <- screen_kmers(sequences_example, response_mat_example, max_gap = 3) #> ℹ Number of response variables: 5 #> ℹ Screening kmers of length 6, from position 0 to position 300 #> ℹ Gaps of length 0:3 are allowed #> ℹ minimal correlation: 0.08 #> ✔ Found 4884 kmers in 1000 sequences. head(kmers) #>       kmer     max_r2 avg_n    avg_var           c1           c2         c3 #> 1   AGATAA 0.05012437 0.139 0.15167901 -0.011159671 -0.033565160 -0.2238847 #> 2  AGA*AAG 0.03404951 0.220 0.23760001  0.062884174  0.063842162 -0.1845251 #> 3   TTATCT 0.02915060 0.127 0.13487099  0.036021627  0.051995803 -0.1707355 #> 4 ACAT**CT 0.02848161 0.090 0.09190000 -0.002383306 -0.023468828 -0.1687650 #> 5  AG*TAAG 0.02829135 0.118 0.12007600  0.034630746 -0.005794165 -0.1682003 #> 6   CTTATC 0.02680831 0.080 0.07960001  0.028614303  0.019679585 -0.1637324 #>            c4          c5 #> 1 0.001539792 -0.03616555 #> 2 0.025056362  0.02373981 #> 3 0.032191906  0.02568413 #> 4 0.019714575 -0.02059141 #> 5 0.046150818  0.02593128 #> 6 0.059437271  0.03772539"},{"path":"/reference/screen_pwm.clusters.html","id":null,"dir":"Reference","previous_headings":"","what":"Screen for motifs in a database for every cluster — screen_pwm.clusters","title":"Screen for motifs in a database for every cluster — screen_pwm.clusters","text":"Screen motifs database every cluster","code":""},{"path":"/reference/screen_pwm.clusters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Screen for motifs in a database for every cluster — screen_pwm.clusters","text":"","code":"screen_pwm.clusters(   sequences,   clusters,   dataset = all_motif_datasets(),   motifs = NULL,   parallel = getOption(\"prego.parallel\", TRUE),   min_D = 0.4,   only_best = FALSE,   prior = 0.01,   alternative = \"two.sided\",   ... )"},{"path":"/reference/screen_pwm.clusters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Screen for motifs in a database for every cluster — screen_pwm.clusters","text":"sequences vector sequences clusters vector cluster assignments dataset data frame PSSMs ('', 'C', 'G' 'T' columns), additional column 'motif' containing motif name, example HOMER_motifs JASPAR_motifs, all_motif_datasets(), MotifDB object. motifs names specific motifs extract dataset parallel logical, whether use parallel processing min_D minimum distance consider match only_best TRUE, return best match cluster prior prior probability nucleotide. alternative alternative hypothesis KS test. Can \"two.sided\", \"less\" \"greater\" ... Arguments passed compute_pwm pssm PSSM matrix data frame. columns matrix data frame named nucleotides ('', 'C', 'G' 'T'). spat data frame spatial model (returned $spat slot regression). contain column called 'bin' column called 'spat_factor'. spat_min minimum position use sequences. default 1. spat_max maximum position use sequences. default length sequences. bidirect motif bi-directional. TRUE, reverse-complement motif used well. func function use combine PWMs sequence. Either 'logSumExp' 'max'. default 'logSumExp'.","code":""},{"path":"/reference/screen_pwm.clusters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Screen for motifs in a database for every cluster — screen_pwm.clusters","text":"matrix KS D statistics cluster (columns) every motif (rows) least one cluster D >= min_D. only_best TRUE, named vector name best motif match cluster returned (regardless min_D).","code":""},{"path":"/reference/screen_pwm.clusters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Screen for motifs in a database for every cluster — screen_pwm.clusters","text":"","code":"if (FALSE) { # \\dontrun{ D_mat <- screen_pwm.clusters(cluster_sequences_example, clusters_example) dim(D_mat) D_mat[1:5, 1:5]  # return only the best match screen_pwm.clusters(cluster_sequences_example, clusters_example, only_best = TRUE) } # }"},{"path":"/reference/screen_pwm.html","id":null,"dir":"Reference","previous_headings":"","what":"Screen for motifs in a database given a response variable — screen_pwm","title":"Screen for motifs in a database given a response variable — screen_pwm","text":"Screen motifs database given response variable","code":""},{"path":"/reference/screen_pwm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Screen for motifs in a database given a response variable — screen_pwm","text":"","code":"screen_pwm(   sequences,   response,   metric = NULL,   dataset = all_motif_datasets(),   motifs = NULL,   parallel = getOption(\"prego.parallel\", TRUE),   only_best = FALSE,   prior = 0.01,   alternative = \"two.sided\",   ... )"},{"path":"/reference/screen_pwm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Screen for motifs in a database given a response variable — screen_pwm","text":"sequences vector sequences response vector response variable sequence. response matrix, average used. metric metric use order choose best motif. One 'ks' 'r2'. NULL - default 'ks' binary variables, 'r2' continuous variables. dataset data frame PSSMs ('', 'C', 'G' 'T' columns), additional column 'motif' containing motif name, example HOMER_motifs JASPAR_motifs, all_motif_datasets(), MotifDB object. motifs names specific motifs extract dataset parallel logical, whether use parallel processing only_best return best motif (one highest score). FALSE, motifs returned. prior prior probability nucleotide. alternative alternative hypothesis KS test. One 'two.sided', 'less' 'greater'. ... Arguments passed compute_pwm pssm PSSM matrix data frame. columns matrix data frame named nucleotides ('', 'C', 'G' 'T'). spat data frame spatial model (returned $spat slot regression). contain column called 'bin' column called 'spat_factor'. spat_min minimum position use sequences. default 1. spat_max maximum position use sequences. default length sequences. bidirect motif bi-directional. TRUE, reverse-complement motif used well. func function use combine PWMs sequence. Either 'logSumExp' 'max'. default 'logSumExp'.","code":""},{"path":"/reference/screen_pwm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Screen for motifs in a database given a response variable — screen_pwm","text":"data frame following columns: motif: motif name. score: score motif (depending metric). only_best TRUE, best motif returned (data framw single row).","code":""},{"path":"/reference/screen_pwm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Screen for motifs in a database given a response variable — screen_pwm","text":"","code":"res_screen <- screen_pwm(cluster_sequences_example, cluster_mat_example[, 1]) #> ℹ Performing PWM screening head(res_screen) #> # A tibble: 6 x 2 #>                            motif     score #> 1 HOCOMOCO.HNF1B_HUMAN.H11MO.0.A 0.8606183 #> 2 HOCOMOCO.HNF1B_MOUSE.H11MO.0.A 0.8510730 #> 3                   JASPAR.HNF1A 0.8510730 #> 4            JOLMA.HNF1A_di_full 0.8505374 #> 5          JOLMA.HNF1B_di_full_1 0.8484232 #> 6          JOLMA.HNF1B_di_full_2 0.8484090  # only best match screen_pwm(cluster_sequences_example, cluster_mat_example[, 1]) #> ℹ Performing PWM screening #> # A tibble: 3,867 x 2 #>                            motif     score #> 1 HOCOMOCO.HNF1B_HUMAN.H11MO.0.A 0.8606183 #> 2 HOCOMOCO.HNF1B_MOUSE.H11MO.0.A 0.8510730 #> 3                   JASPAR.HNF1A 0.8510730 #> 4            JOLMA.HNF1A_di_full 0.8505374 #> 5          JOLMA.HNF1B_di_full_1 0.8484232 #> 6          JOLMA.HNF1B_di_full_2 0.8484090 #> # ... with 3,861 more rows  # with r^2 metric res_screen <- screen_pwm(sequences_example, response_mat_example[, 1], metric = \"r2\") #> ℹ Performing PWM screening head(res_screen) #> # A tibble: 6 x 2 #>               motif      score #> 1       JASPAR.SOX2 0.04355104 #> 2       JASPAR.SUT1 0.04011911 #> 3      JASPAR.SOX13 0.03979195 #> 4 JOLMA.IRX3_di_DBD 0.03947626 #> 5        JASPAR.dsx 0.03903626 #> 6       JASPAR.Sox3 0.03876807"},{"path":"/reference/set_parallel.html","id":null,"dir":"Reference","previous_headings":"","what":"Set parallel threads — set_parallel","title":"Set parallel threads — set_parallel","text":"Set number parallel threads use. prego uses R function doMC::registerDoMC register parallelization. default, prego uses 80% number available cores. options saved 'prego.parallel' (use parallelization, logical) 'prego.parallel.nc' (number cores use, integer).","code":""},{"path":"/reference/set_parallel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set parallel threads — set_parallel","text":"","code":"set_parallel(thread_num = max(1, round(parallel::detectCores() * 0.8)))"},{"path":"/reference/set_parallel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set parallel threads — set_parallel","text":"thread_num number threads. use '1' non parallel behavior","code":""},{"path":"/reference/set_parallel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set parallel threads — set_parallel","text":"None","code":""},{"path":"/reference/set_parallel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set parallel threads — set_parallel","text":"","code":"# \\donttest{ set_parallel(8) # }"},{"path":"/reference/show-MotifDB-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Show method for MotifDB objects — show,MotifDB-method","title":"Show method for MotifDB objects — show,MotifDB-method","text":"Show method MotifDB objects","code":""},{"path":"/reference/show-MotifDB-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show method for MotifDB objects — show,MotifDB-method","text":"","code":"# S4 method for class 'MotifDB' show(object)"},{"path":"/reference/show-MotifDB-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Show method for MotifDB objects — show,MotifDB-method","text":"object MotifDB object","code":""},{"path":"/reference/sub-MotifDB-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Get specific motifs from the MotifDB — [,MotifDB-method","title":"Get specific motifs from the MotifDB — [,MotifDB-method","text":"Get specific motifs MotifDB","code":""},{"path":"/reference/sub-MotifDB-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get specific motifs from the MotifDB — [,MotifDB-method","text":"","code":"# S4 method for class 'MotifDB' x[i, j, ..., pattern = FALSE, drop = TRUE]"},{"path":"/reference/sub-MotifDB-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get specific motifs from the MotifDB — [,MotifDB-method","text":"x MotifDB object Character vector motif names, numeric indices, regex pattern(s) j used ... used pattern Logical indicating whether treat character input regex pattern (default: FALSE) drop used","code":""},{"path":"/reference/sub-MotifDB-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get specific motifs from the MotifDB — [,MotifDB-method","text":"MotifDB object containing specified motifs","code":""},{"path":"/reference/trim_pssm.html","id":null,"dir":"Reference","previous_headings":"","what":"Trim PSSM — trim_pssm","title":"Trim PSSM — trim_pssm","text":"function trims Position-Specific Scoring Matrix (PSSM) removing positions low information content beginning end motif.","code":""},{"path":"/reference/trim_pssm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Trim PSSM — trim_pssm","text":"","code":"trim_pssm(pssm, bits_thresh = 0.1)"},{"path":"/reference/trim_pssm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Trim PSSM — trim_pssm","text":"pssm data frame representing PSSM, columns position (pos) bits per position (bits). bits_thresh threshold value bits per position. Positions bits threshold kept, positions bits threshold beginning end motif removed. default value 0.1.","code":""},{"path":"/reference/trim_pssm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Trim PSSM — trim_pssm","text":"trimmed PSSM data frame, positions filtered based bits threshold.","code":""},{"path":"/news/index.html","id":"prego-003","dir":"Changelog","previous_headings":"","what":"prego 0.0.3","title":"prego 0.0.3","text":"Added MotifDB object store motif information. Implmented faster energy computation method, now used default.","code":""},{"path":"/news/index.html","id":"prego-0009000","dir":"Changelog","previous_headings":"","what":"prego 0.0.0.9000","title":"prego 0.0.0.9000","text":"Added NEWS.md file track changes package.","code":""}]
