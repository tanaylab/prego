[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 Weizmann Institute Science Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Aviezer Lifshitz. Author, maintainer. Amos Tanay. Author.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lifshitz , Tanay (2022). prego: PWM Regression Optimizer. R package version 0.0.0.9000.","code":"@Manual{,   title = {prego: PWM Regression Optimizer},   author = {Aviezer Lifshitz and Amos Tanay},   year = {2022},   note = {R package version 0.0.0.9000}, }"},{"path":"/index.html","id":"prego","dir":"","previous_headings":"","what":"PWM Regression Optimizer","title":"PWM Regression Optimizer","text":"prego package implements simple regression algorithms finding motifs DNA. can either use find motif discriminating two clusters DNA sequences, generting motifs one continuous variables. PREGO algorithm described .","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"PWM Regression Optimizer","text":"can install development version prego like :","code":"remotes::install_github(\"tanaylab/prego\")"},{"path":"/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"PWM Regression Optimizer","text":"set continuous variables:  binary response:  clusters sequences:","code":"library(prego) res <- regress_pwm(sequences_example, response_mat_example) #> ℹ Number of response variables: 5 #> ℹ Screening for kmers in order to initialize regression #> ℹ Number of response variables: 5 #> ℹ Screening kmers of length 8, from position 0 to position 300 #> ℹ minimal correlation: 0.08, minimal number of occurrences: 50 #> ✔ Found 2138 kmers in 1000 sequences. #> ℹ Motif is shorter than 15, extending with wildcards #> ℹ Initializing regression with the following motif: \"***TTTACAAC****\" #> ℹ Running regression #> • Motif length: 15 #> • Bidirectional: TRUE #> • Spat min: 0 #> • Spat max: 300 #> • Spat bin: 50 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> ✔ Finished running regression. Consensus: \"TTACRAC\" #> ✔ R^2: 0.01, 0.0054, 0.0373, 0.0002, and 0.0087 plot_regression_qc(res) #> Warning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> = \"none\")` instead. #> `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> = \"none\")` instead. res_binary <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1]) #> ℹ Number of response variables: 1 #> ℹ Screening for kmers in order to initialize regression #> ℹ Number of response variables: 1 #> ℹ Screening kmers of length 8, from position 0 to position 300 #> ℹ minimal correlation: 0.08, minimal number of occurrences: 50 #> ✔ Found 198 kmers in 2359 sequences. #> ℹ Motif is shorter than 15, extending with wildcards #> ℹ Initializing regression with the following motif: \"***TAATCATT****\" #> ℹ Running regression #> • Motif length: 15 #> • Bidirectional: TRUE #> • Spat min: 0 #> • Spat max: 300 #> • Spat bin: 50 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> ✔ Finished running regression. Consensus: \"T*A***W*T\" #> ✔ KS test D: 0.8507, p-value: 0 plot_regression_qc(res_binary) #> Warning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> = \"none\")` instead. #> `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> = \"none\")` instead. res <- regress_pwm.clusters(cluster_sequences_example, clusters_example) #> ℹ Using single-phase optimization #> ℹ Running regression for 5 clusters #> ℹ Matching with motif databases res$stats #> # A tibble: 5 x 6 #>   cluster consensus      ks_D        r2      seed_motif              db_match #> 1    c100   AT***TC 0.7024075 0.3852463 ***ATCCATCA**** JOLMA.DLX2_mono_DBD_1 #> 2    c111   Y*RTAAA 0.8479663 0.4978355 ***CAATTAAC****           JASPAR.CDX1 #> 3     c29 T*A***W*T 0.8507039 0.5581745 ***TAATCATT****            HOMER.Hnf1 #> 4      c5      GATA 0.5887910 0.2227806 ***CTGATAAG****         HOMER.GATA3_2 #> 5      c6      TATC 0.6160721 0.2783910 ***TCTTATCT****     HOMER.GAGA_repeat"},{"path":"/reference/all_motif_datasets.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a data frame of all the motif datasets bundled with prego — all_motif_datasets","title":"Get a data frame of all the motif datasets bundled with prego — all_motif_datasets","text":"data frame contain PSSMs ('', 'C', 'G' 'T' columns), additional column 'motif' containing motif name. Individual datasets available within package HOMER_motifs, JASPAR_motifs, JOLMA_motifs.","code":""},{"path":"/reference/all_motif_datasets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a data frame of all the motif datasets bundled with prego — all_motif_datasets","text":"","code":"all_motif_datasets()"},{"path":"/reference/all_motif_datasets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a data frame of all the motif datasets bundled with prego — all_motif_datasets","text":"data frame concatenates motifs \"HOMER\", \"JASPAR\" \"JOLMA\". Motif names prefixed dataset name, e.g. \"JASPAR.GATA4\".","code":""},{"path":"/reference/all_motif_datasets.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Get a data frame of all the motif datasets bundled with prego — all_motif_datasets","text":"HOMER:  Heinz S, Benner C, Spann N, Bertolino E et al. Simple Combinations Lineage-Determining Transcription Factors Prime cis-Regulatory Elements Required Macrophage B Cell Identities. Mol Cell 2010 May 28;38(4):576-589. PMID: 20513432 JASPAR: Castro-Mondragon JA, Riudavets-Puig R, Rauluseviciute , Berhanu Lemma R, Turchi L, Blanc-Mathieu R, Lucas J, Boddie P, Khan , Manosalva Pérez N, Fornes O, Leung TY, Aguirre , Hammal F, Schmelter D, Baranasic D, Ballester B, Sandelin , Lenhard B, Vandepoele K, Wasserman WW, Parcy F, Mathelier JASPAR 2022: 9th release open-access database transcription factor binding profiles Nucleic Acids Res. 2022 Jan 7;50(D1):D165-D173.; doi: 10.1093/nar/gkab1113 JOLMA: Jolma, ., Yin, Y., Nitta, K. et al. DNA-dependent formation transcription factor pairs alters binding specificity. Nature 534, S15–S16 (2016). https://doi.org/10.1038/nature18912","code":""},{"path":"/reference/all_motif_datasets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a data frame of all the motif datasets bundled with prego — all_motif_datasets","text":"","code":"all_motif_datasets() #> # A tibble: 38,758 x 8 #>        motif pos     A     C     G     T dataset motif_orig #> 1 HOMER.AP_1   0 0.419 0.275 0.277 0.028   HOMER       AP_1 #> 2 HOMER.AP_1   1 0.001 0.001 0.001 0.997   HOMER       AP_1 #> 3 HOMER.AP_1   2 0.010 0.002 0.965 0.023   HOMER       AP_1 #> 4 HOMER.AP_1   3 0.984 0.003 0.001 0.012   HOMER       AP_1 #> 5 HOMER.AP_1   4 0.062 0.579 0.305 0.054   HOMER       AP_1 #> 6 HOMER.AP_1   5 0.026 0.001 0.001 0.972   HOMER       AP_1 #> # ... with 38,752 more rows"},{"path":"/reference/compute_pwm.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute PWMs for a set of sequences given a PSSM matrix — compute_pwm","title":"Compute PWMs for a set of sequences given a PSSM matrix — compute_pwm","text":"Compute PWMs set sequences given PSSM matrix","code":""},{"path":"/reference/compute_pwm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute PWMs for a set of sequences given a PSSM matrix — compute_pwm","text":"","code":"compute_pwm(   sequences,   pssm,   spat = NULL,   spat_min = 0,   spat_max = NULL,   bidirect = TRUE )"},{"path":"/reference/compute_pwm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute PWMs for a set of sequences given a PSSM matrix — compute_pwm","text":"sequences vector sequences pssm PSSM matrix data frame. columns matrix data frame named nucleotides ('', 'C', 'G' 'T'). spat data frame spatial model (returned $spat slot regression). contain column called 'bin' column called 'spat_factor'. spat_min start spatial model beginning sequence (bp) spat_max end spatial model beginning sequence (bp). NULL - spatial model end end sequence. bidirect motif bi-directional. TRUE, reverse-complement motif used well.","code":""},{"path":"/reference/compute_pwm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute PWMs for a set of sequences given a PSSM matrix — compute_pwm","text":"vector predicted pwm sequence.","code":""},{"path":"/reference/compute_pwm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute PWMs for a set of sequences given a PSSM matrix — compute_pwm","text":"","code":"res <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1]) #> ℹ Number of response variables: 1 #> ℹ Screening for kmers in order to initialize regression #> ℹ Number of response variables: 1 #> ℹ Screening kmers of length 8, from position 0 to position 300 #> ℹ minimal correlation: 0.08, minimal number of occurrences: 50 #> ✔ Found 198 kmers in 2359 sequences. #> ℹ Motif is shorter than 15, extending with wildcards #> ℹ Initializing regression with the following motif: \"***TAATCATT****\" #> ℹ Running regression #> • Motif length: 15 #> • Bidirectional: TRUE #> • Spat min: 0 #> • Spat max: 300 #> • Spat bin: 50 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> ✔ Finished running regression. Consensus: \"T*A***W*T\" #> ✔ KS test D: 0.8507, p-value: 0  pwm <- compute_pwm(cluster_sequences_example, res$pssm, res$spat) head(pwm) #> [1] -16.43380 -16.51139 -16.80705 -15.20886 -15.35405 -14.44998  # this is similar to the prediction in the regression head(res$pred) #> [1] -16.43380 -16.51139 -16.80705 -15.20886 -15.35405 -14.44998"},{"path":"/reference/consensus_from_pssm.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert PSSM to kmer using majority — consensus_from_pssm","title":"Convert PSSM to kmer using majority — consensus_from_pssm","text":"Convert PSSM kmer using majority","code":""},{"path":"/reference/consensus_from_pssm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert PSSM to kmer using majority — consensus_from_pssm","text":"","code":"consensus_from_pssm(pssm, single_thresh = 0.6, double_thresh = 0.85)"},{"path":"/reference/consensus_from_pssm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert PSSM to kmer using majority — consensus_from_pssm","text":"pssm PSSM matrix single_thresh, double_thresh thresholds consensus sequence calculation (single double nucleotides)","code":""},{"path":"/reference/consensus_from_pssm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert PSSM to kmer using majority — consensus_from_pssm","text":"consensus sequence PSSM. consensus sequence can found, function returns NA.","code":""},{"path":"/reference/consensus_from_pssm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert PSSM to kmer using majority — consensus_from_pssm","text":"","code":"res <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1]) #> ℹ Number of response variables: 1 #> ℹ Screening for kmers in order to initialize regression #> ℹ Number of response variables: 1 #> ℹ Screening kmers of length 8, from position 0 to position 300 #> ℹ minimal correlation: 0.08, minimal number of occurrences: 50 #> ✔ Found 198 kmers in 2359 sequences. #> ℹ Motif is shorter than 15, extending with wildcards #> ℹ Initializing regression with the following motif: \"***TAATCATT****\" #> ℹ Running regression #> • Motif length: 15 #> • Bidirectional: TRUE #> • Spat min: 0 #> • Spat max: 300 #> • Spat bin: 50 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> ✔ Finished running regression. Consensus: \"T*A***W*T\" #> ✔ KS test D: 0.8507, p-value: 0 consensus_from_pssm(res$pssm) #> [1] \"T*A***W*T\""},{"path":"/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See dplyr::%>% details.","code":""},{"path":"/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value dplyr placeholder. rhs function call using dplyr semantics.","code":""},{"path":"/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"/reference/plot_pssm_logo.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot LOGO of the pssm result from the regression — plot_pssm_logo","title":"Plot LOGO of the pssm result from the regression — plot_pssm_logo","text":"Plot LOGO pssm result regression","code":""},{"path":"/reference/plot_pssm_logo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot LOGO of the pssm result from the regression — plot_pssm_logo","text":"","code":"plot_pssm_logo(pssm, title = \"Sequence model\", subtitle = ggplot2::waiver())"},{"path":"/reference/plot_pssm_logo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot LOGO of the pssm result from the regression — plot_pssm_logo","text":"pssm 'pssm' field regression result title title plot subtitle subtitle plot","code":""},{"path":"/reference/plot_pssm_logo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot LOGO of the pssm result from the regression — plot_pssm_logo","text":"ggplot object","code":""},{"path":"/reference/plot_pssm_logo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot LOGO of the pssm result from the regression — plot_pssm_logo","text":"","code":"res <- regress_pwm(sequences_example, response_mat_example) #> ℹ Number of response variables: 5 #> ℹ Screening for kmers in order to initialize regression #> ℹ Number of response variables: 5 #> ℹ Screening kmers of length 8, from position 0 to position 300 #> ℹ minimal correlation: 0.08, minimal number of occurrences: 50 #> ✔ Found 2138 kmers in 1000 sequences. #> ℹ Motif is shorter than 15, extending with wildcards #> ℹ Initializing regression with the following motif: \"***TTTACAAC****\" #> ℹ Running regression #> • Motif length: 15 #> • Bidirectional: TRUE #> • Spat min: 0 #> • Spat max: 300 #> • Spat bin: 50 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> ✔ Finished running regression. Consensus: \"TTACRAC\" #> ✔ R^2: 0.01, 0.0054, 0.0373, 0.0002, and 0.0087 plot_pssm_logo(res$pssm) #> Warning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> = \"none\")` instead."},{"path":"/reference/plot_pssm_logo_dataset.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot LOGO of pssm from dataset (e.g. ","title":"Plot LOGO of pssm from dataset (e.g. ","text":"Plot LOGO pssm dataset (e.g. \"HOMER\" \"JASPAR\")","code":""},{"path":"/reference/plot_pssm_logo_dataset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot LOGO of pssm from dataset (e.g. ","text":"","code":"plot_pssm_logo_dataset(   motif,   dataset = all_motif_datasets(),   title = motif,   subtitle = ggplot2::waiver() )"},{"path":"/reference/plot_pssm_logo_dataset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot LOGO of pssm from dataset (e.g. ","text":"motif motif name (e.g. \"GATA4\") dataset data frame PSSMs ('', 'C', 'G' 'T' columns), additional column 'motif' containing motif name, example HOMER_motifs JASPAR_motifs title title plot subtitle subtitle plot","code":""},{"path":"/reference/plot_pssm_logo_dataset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot LOGO of pssm from dataset (e.g. ","text":"ggplot object","code":""},{"path":"/reference/plot_pssm_logo_dataset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot LOGO of pssm from dataset (e.g. ","text":"","code":"plot_pssm_logo_dataset(\"JASPAR.Brachyury\") #> Warning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> = \"none\")` instead.   plot_pssm_logo_dataset(\"GATA5\", JASPAR_motifs) #> Warning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> = \"none\")` instead."},{"path":"/reference/plot_regression_prediction.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot response variable averages vs the regression model's prediction — plot_regression_prediction","title":"Plot response variable averages vs the regression model's prediction — plot_regression_prediction","text":"return scatter plot response variable averages vs regression model's prediction","code":""},{"path":"/reference/plot_regression_prediction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot response variable averages vs the regression model's prediction — plot_regression_prediction","text":"","code":"plot_regression_prediction(pred, response, point_size = 0.5)"},{"path":"/reference/plot_regression_prediction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot response variable averages vs the regression model's prediction — plot_regression_prediction","text":"pred 'pred' field regression result response 'response' field regression result (response variable) point_size size points plot (default: 0.5)","code":""},{"path":"/reference/plot_regression_prediction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot response variable averages vs the regression model's prediction — plot_regression_prediction","text":"","code":"res <- regress_pwm(sequences_example, response_mat_example) #> ℹ Number of response variables: 5 #> ℹ Screening for kmers in order to initialize regression #> ℹ Number of response variables: 5 #> ℹ Screening kmers of length 8, from position 0 to position 300 #> ℹ minimal correlation: 0.08, minimal number of occurrences: 50 #> ✔ Found 2138 kmers in 1000 sequences. #> ℹ Motif is shorter than 15, extending with wildcards #> ℹ Initializing regression with the following motif: \"***TTTACAAC****\" #> ℹ Running regression #> • Motif length: 15 #> • Bidirectional: TRUE #> • Spat min: 0 #> • Spat max: 300 #> • Spat bin: 50 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> ✔ Finished running regression. Consensus: \"TTACRAC\" #> ✔ R^2: 0.01, 0.0054, 0.0373, 0.0002, and 0.0087 plot_regression_prediction(res$pred, res$response)"},{"path":"/reference/plot_regression_prediction_binary.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the comulative of the regression model's prediction stratified by the response variable — plot_regression_prediction_binary","title":"Plot the comulative of the regression model's prediction stratified by the response variable — plot_regression_prediction_binary","text":"Plot comulative regression model's prediction stratified response variable","code":""},{"path":"/reference/plot_regression_prediction_binary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the comulative of the regression model's prediction stratified by the response variable — plot_regression_prediction_binary","text":"","code":"plot_regression_prediction_binary(pred, response)"},{"path":"/reference/plot_regression_prediction_binary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the comulative of the regression model's prediction stratified by the response variable — plot_regression_prediction_binary","text":"pred 'pred' field regression result response 'response' field regression result (response variable). binary (0/1).","code":""},{"path":"/reference/plot_regression_prediction_binary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the comulative of the regression model's prediction stratified by the response variable — plot_regression_prediction_binary","text":"","code":"res_binary <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1], score_metric = \"ks\") #> ℹ Number of response variables: 1 #> ℹ Screening for kmers in order to initialize regression #> ℹ Number of response variables: 1 #> ℹ Screening kmers of length 8, from position 0 to position 300 #> ℹ minimal correlation: 0.08, minimal number of occurrences: 50 #> ✔ Found 198 kmers in 2359 sequences. #> ℹ Motif is shorter than 15, extending with wildcards #> ℹ Initializing regression with the following motif: \"***TAATCATT****\" #> ℹ Running regression #> • Motif length: 15 #> • Bidirectional: TRUE #> • Spat min: 0 #> • Spat max: 300 #> • Spat bin: 50 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"ks\" #> • Seed: 60427 #> ✔ Finished running regression. Consensus: \"TAATCATT\" #> ✔ KS test D: 0.6552, p-value: 0 plot_regression_prediction_binary(res_binary$pred, res_binary$response)"},{"path":"/reference/plot_regression_qc.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the regression results — plot_regression_qc","title":"Plot the regression results — plot_regression_qc","text":"Plot QC regression results","code":""},{"path":"/reference/plot_regression_qc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the regression results — plot_regression_qc","text":"","code":"plot_regression_qc(   reg,   response = NULL,   title = glue(\"Motif regression results (consensus: {reg$consensus})\"),   subtitle = NULL,       caption = glue(\"# of 1: {sum(response == 1)}, # of 0: {sum(response == 0)}, seed: {reg$seed_motif}\") )"},{"path":"/reference/plot_regression_qc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the regression results — plot_regression_qc","text":"reg output regress_pwm response response variable title title plot (optional) subtitle subtitle plot (optional) caption caption plot (optional)","code":""},{"path":"/reference/plot_regression_qc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the regression results — plot_regression_qc","text":"patchwork object","code":""},{"path":"/reference/plot_regression_qc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the regression results — plot_regression_qc","text":"","code":"res <- regress_pwm(sequences_example, response_mat_example) #> ℹ Number of response variables: 5 #> ℹ Screening for kmers in order to initialize regression #> ℹ Number of response variables: 5 #> ℹ Screening kmers of length 8, from position 0 to position 300 #> ℹ minimal correlation: 0.08, minimal number of occurrences: 50 #> ✔ Found 2138 kmers in 1000 sequences. #> ℹ Motif is shorter than 15, extending with wildcards #> ℹ Initializing regression with the following motif: \"***TTTACAAC****\" #> ℹ Running regression #> • Motif length: 15 #> • Bidirectional: TRUE #> • Spat min: 0 #> • Spat max: 300 #> • Spat bin: 50 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> ✔ Finished running regression. Consensus: \"TTACRAC\" #> ✔ R^2: 0.01, 0.0054, 0.0373, 0.0002, and 0.0087 plot_regression_qc(res) #> Warning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> = \"none\")` instead. #> Warning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> = \"none\")` instead.   res_binary <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1]) #> ℹ Number of response variables: 1 #> ℹ Screening for kmers in order to initialize regression #> ℹ Number of response variables: 1 #> ℹ Screening kmers of length 8, from position 0 to position 300 #> ℹ minimal correlation: 0.08, minimal number of occurrences: 50 #> ✔ Found 198 kmers in 2359 sequences. #> ℹ Motif is shorter than 15, extending with wildcards #> ℹ Initializing regression with the following motif: \"***TAATCATT****\" #> ℹ Running regression #> • Motif length: 15 #> • Bidirectional: TRUE #> • Spat min: 0 #> • Spat max: 300 #> • Spat bin: 50 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> ✔ Finished running regression. Consensus: \"T*A***W*T\" #> ✔ KS test D: 0.8507, p-value: 0 plot_regression_qc(res_binary) #> Warning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> = \"none\")` instead. #> Warning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> = \"none\")` instead."},{"path":"/reference/plot_spat_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot spatial model of the regression result — plot_spat_model","title":"Plot spatial model of the regression result — plot_spat_model","text":"Plot spatial model regression result","code":""},{"path":"/reference/plot_spat_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot spatial model of the regression result — plot_spat_model","text":"","code":"plot_spat_model(spat)"},{"path":"/reference/plot_spat_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot spatial model of the regression result — plot_spat_model","text":"spat 'spat' field regression result","code":""},{"path":"/reference/plot_spat_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot spatial model of the regression result — plot_spat_model","text":"","code":"res <- regress_pwm(sequences_example, response_mat_example) #> ℹ Number of response variables: 5 #> ℹ Screening for kmers in order to initialize regression #> ℹ Number of response variables: 5 #> ℹ Screening kmers of length 8, from position 0 to position 300 #> ℹ minimal correlation: 0.08, minimal number of occurrences: 50 #> ✔ Found 2138 kmers in 1000 sequences. #> ℹ Motif is shorter than 15, extending with wildcards #> ℹ Initializing regression with the following motif: \"***TTTACAAC****\" #> ℹ Running regression #> • Motif length: 15 #> • Bidirectional: TRUE #> • Spat min: 0 #> • Spat max: 300 #> • Spat bin: 50 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> ✔ Finished running regression. Consensus: \"TTACRAC\" #> ✔ R^2: 0.01, 0.0054, 0.0373, 0.0002, and 0.0087 plot_spat_model(res$spat)"},{"path":"/reference/prego-package.html","id":null,"dir":"Reference","previous_headings":"","what":"prego: PWM Regression Optimizer — prego-package","title":"prego: PWM Regression Optimizer — prego-package","text":"PREGO implements regression algorithms finding motifs DNA. contains algorithms described : \"Extensive low-affinity transcriptional interactions yeast genome\" doi:10.1101/gr.5113606 .","code":""},{"path":"/reference/prego-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"prego: PWM Regression Optimizer — prego-package","text":"Maintainer: Aviezer Lifshitz aviezer.lifshitz@weizmann.ac.il Authors: Amos Tanay amos.tanay@weizmann.ac.il","code":""},{"path":"/reference/pssm_diff.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute PSSM difference — pssm_diff","title":"Compute PSSM difference — pssm_diff","text":"Compute PSSM difference","code":""},{"path":"/reference/pssm_diff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute PSSM difference — pssm_diff","text":"","code":"pssm_diff(pssm1, pssm2)"},{"path":"/reference/pssm_diff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute PSSM difference — pssm_diff","text":"pssm1 first PSSM matrix data frame pssm2 second PSSM matrix data frame","code":""},{"path":"/reference/pssm_diff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute PSSM difference — pssm_diff","text":"KL divergence two PSSMs","code":""},{"path":"/reference/pssm_diff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute PSSM difference — pssm_diff","text":"","code":"res1 <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1]) #> ℹ Number of response variables: 1 #> ℹ Screening for kmers in order to initialize regression #> ℹ Number of response variables: 1 #> ℹ Screening kmers of length 8, from position 0 to position 300 #> ℹ minimal correlation: 0.08, minimal number of occurrences: 50 #> ✔ Found 198 kmers in 2359 sequences. #> ℹ Motif is shorter than 15, extending with wildcards #> ℹ Initializing regression with the following motif: \"***TAATCATT****\" #> ℹ Running regression #> • Motif length: 15 #> • Bidirectional: TRUE #> • Spat min: 0 #> • Spat max: 300 #> • Spat bin: 50 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> ✔ Finished running regression. Consensus: \"T*A***W*T\" #> ✔ KS test D: 0.8507, p-value: 0 pssm_diff(res1$pssm, JASPAR_motifs[JASPAR_motifs$motif == \"HNF1A\", ]) #> [1] 0.4198401"},{"path":"/reference/pssm_match.html","id":null,"dir":"Reference","previous_headings":"","what":"Match PSSM to a directory of motifs — pssm_match","title":"Match PSSM to a directory of motifs — pssm_match","text":"Match PSSM directory motifs","code":""},{"path":"/reference/pssm_match.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match PSSM to a directory of motifs — pssm_match","text":"","code":"pssm_match(   pssm,   motifs,   best = FALSE,   parallel = getOption(\"prego.parallel\", TRUE) )"},{"path":"/reference/pssm_match.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match PSSM to a directory of motifs — pssm_match","text":"pssm PSSM matrix data frame motifs data frame PSSMs ('', 'C', 'G' 'T' columns), additional column 'motif' containing motif name best return best match parallel use parallel processing. Set number cores using set_parallel.","code":""},{"path":"/reference/pssm_match.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match PSSM to a directory of motifs — pssm_match","text":"best TRUE, string best match. Otherwise, data frame row per motif column named 'dist' distance pssm. data frame sorted increasing distance.","code":""},{"path":"/reference/pssm_match.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Match PSSM to a directory of motifs — pssm_match","text":"","code":"res1 <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1]) #> ℹ Number of response variables: 1 #> ℹ Screening for kmers in order to initialize regression #> ℹ Number of response variables: 1 #> ℹ Screening kmers of length 8, from position 0 to position 300 #> ℹ minimal correlation: 0.08, minimal number of occurrences: 50 #> ✔ Found 198 kmers in 2359 sequences. #> ℹ Motif is shorter than 15, extending with wildcards #> ℹ Initializing regression with the following motif: \"***TAATCATT****\" #> ℹ Running regression #> • Motif length: 15 #> • Bidirectional: TRUE #> • Spat min: 0 #> • Spat max: 300 #> • Spat bin: 50 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> ✔ Finished running regression. Consensus: \"T*A***W*T\" #> ✔ KS test D: 0.8507, p-value: 0 head(pssm_match(res1$pssm, JASPAR_motifs)) #>    motif      dist #> 1   Hox1 0.3511553 #> 2 Lhx3/4 0.3538776 #> 3    Rax 0.3565490 #> 4 Uncx-b 0.3568905 #> 5   Nkx3 0.3583501 #> 6   Noto 0.3709595 pssm_match(res1$pssm, JASPAR_motifs, best = TRUE) #> [1] \"Hox1\""},{"path":"/reference/regress_pwm.clusters.html","id":null,"dir":"Reference","previous_headings":"","what":"Run PWM regression on clusters — regress_pwm.clusters","title":"Run PWM regression on clusters — regress_pwm.clusters","text":"Run PWM regression clusters","code":""},{"path":"/reference/regress_pwm.clusters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run PWM regression on clusters — regress_pwm.clusters","text":"","code":"regress_pwm.clusters(   sequences,   clusters,   two_phase = FALSE,   match_with_db = TRUE,   two_phase_sample_frac = c(0.1, 1),   first_phase_metric = \"ks\",   parallel = getOption(\"prego.parallel\", TRUE),   ... )"},{"path":"/reference/regress_pwm.clusters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run PWM regression on clusters — regress_pwm.clusters","text":"sequences vector DNA sequences ('', 'T', 'C' 'G'. go toupper) clusters vector cluster assignments sequence two_phase whether use two-phase optimization (default: FALSE). match_with_db match resulting PWMs motif databases using pssm_match. add column named 'db_match' stats data frame. Note closest match returned, even similar enough absolute terms. two_phase_sample_frac vector two numbers, specifying fraction sequences use first phase optimization sequences cluster (first number) cluster (second number). first_phase_metric metric use order choose best motif first phase optimization. One 'ks' 'r2'. Note unlike score_metric used regression , metric used choosing best motif first phase optimization runs sampled dataset. parallel whether run first phase optimization parallel. use set_parallel set number cores use. ... Arguments passed regress_pwm, regress_pwm.two_phase response matrix response variables - number rows equal number sequences motif Initial motif start regression . Can either string kmer character \"*\" indicates wildcard data frame pre-computed PSSM (see thre slot pssm return value function). NULL - K-mer screen performed order find best kmer initialization. motif_length Length seed motif. motif shorter , extended wildcards (stars). Note motif longer , truncated. score_metric metric use optimizing PWM. One \"r2\" \"ks\". using \"ks\" response variable single vector 0 1. bidirect motif bi-directional. TRUE, reverse-complement motif used well. spat_min start spatial model beginning sequence (bp) spat_max end spatial model beginning sequence (bp). NULL - spatial model end end sequence. spat_bin size spatial bin (bp). spat_model previously computed spatial model (see spat) return value function. can used motif previously computed PSSM. improve_epsilon minimum improve objective function continue optimization min_nuc_prob minimum nucleotide probability every iteration unif_prior uniform prior nucleotide probabilities include_response include response resulting list (default: TRUE) verbose show verbose messages. seed random seed consensus_single_thresh,consensus_double_thresh thresholds consensus sequence calculation (single double nucleotides) kmer_length number non-gap characters motifs screened is_train boolean vector determine subset sequences use screening first_phase_idxs indices sequences use first phase optimization. NULL, indices sampled using two_phase_sample_frac. min_gap,max_gap length gap considered pattern. one gap, length min_gap:max_gap, used, located anywhere motif. Note greatly expand search space (increase multiple tesing severly).","code":""},{"path":"/reference/regress_pwm.clusters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run PWM regression on clusters — regress_pwm.clusters","text":"list following elements: models: list models cluster cluster_mat: indicator matrix cluster assignments pred_mat: matrix predicted pwm sequence (rows) cluster (columns) stats: data frame statistics cluster","code":""},{"path":"/reference/regress_pwm.clusters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run PWM regression on clusters — regress_pwm.clusters","text":"","code":"res <- regress_pwm.clusters(cluster_sequences_example, clusters_example) #> ℹ Using single-phase optimization #> ℹ Running regression for 5 clusters #> ℹ Matching with motif databases head(res$pred_mat) #>                           c100      c111       c29        c5        c6 #> chr1_5108540_5108840 -17.28819 -15.88604 -16.43380 -16.61165 -16.84203 #> chr1_7313460_7313760 -14.69661 -17.02461 -16.51139 -16.67072 -17.51148 #> chr1_7778180_7778480 -15.75232 -15.11354 -16.80705 -16.65310 -16.69591 #> chr1_9381040_9381340 -16.03874 -15.04809 -15.20886 -16.47437 -16.01101 #> chr1_9921360_9921660 -14.85159 -17.90363 -15.35405 -16.13744 -16.07321 #> chr1_9931940_9932240 -16.32993 -17.16320 -14.44998 -16.72751 -16.53625 res$stats #> # A tibble: 5 x 7 #>   cluster consensus      ks_D        r2      seed_motif              db_match #> 1    c100   AT***TC 0.7024075 0.3852463 ***ATCCATCA**** JASPAR.MEIS1.MA1639.1 #> 2    c111   Y*RTAAA 0.8479663 0.4978355 ***CAATTAAC****   JOLMA.CDX1_mono_DBD #> 3     c29 T*A***W*T 0.8507039 0.5581745 ***TAATCATT****            HOMER.Hnf1 #> 4      c5      GATA 0.5887910 0.2227806 ***CTGATAAG****      JASPAR.GATA1/2/3 #> 5      c6      TATC 0.6160721 0.2783910 ***TCTTATCT****          JASPAR.GATAd #>   db_match_dist #> 1      0.244724 #> 2      0.152716 #> 3      0.340463 #> 4      0.198050 #> 5      0.219126  plot_regression_qc(res$models[[1]], title = names(res$models)[1]) #> Warning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> = \"none\")` instead. #> Warning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> = \"none\")` instead."},{"path":"/reference/regress_pwm.cv.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validate a PWMregression model — regress_pwm.cv","title":"Cross-validate a PWMregression model — regress_pwm.cv","text":"Perform cross-validation PWM regression model. can either provide explicit folds, use nfolds argument set number folds. response binary (0 1) categories vector given, folds stratified response/categories.","code":""},{"path":"/reference/regress_pwm.cv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validate a PWMregression model — regress_pwm.cv","text":"","code":"regress_pwm.cv(   sequences,   response,   nfolds = NULL,   metric = NULL,   folds = NULL,   categories = NULL,   two_phase = TRUE,   seed = 60427,   parallel = getOption(\"prego.parallel\", FALSE),   add_full_model = TRUE,   ... )"},{"path":"/reference/regress_pwm.cv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validate a PWMregression model — regress_pwm.cv","text":"sequences vector DNA sequences ('', 'T', 'C' 'G'. go toupper) response matrix response variables - number rows equal number sequences nfolds number folds cross-validation. Can NULL folds provided. metric metric use cross-validation. One 'ks' 'r2'. NULL - 'ks' set binary response 'r2' continuous response. folds vector fold numbers sequence (optional) categories vector categories sequence (optional) two_phase whether use two-phase optimization . seed random seed parallel whether run cross-validation parallel. add_full_model whether add full model (without cross-validation) results.","code":""},{"path":"/reference/regress_pwm.cv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-validate a PWMregression model — regress_pwm.cv","text":"list following elements: cv_models: list models, one fold. cv_pred: vector predictions sequence. score: score model cross-validated predictions. cv_scores: vector scores fold. folds: vector fold number sequence. full_model: full model (without cross-validation), add_full_model TRUE.","code":""},{"path":"/reference/regress_pwm.cv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validate a PWMregression model — regress_pwm.cv","text":"","code":"res <- regress_pwm.cv(cluster_sequences_example, cluster_mat_example[, 1], nfolds = 5, two_phase = TRUE, two_phase_sample_frac = c(0.1, 1)) #> ℹ Stratified sampling #> ℹ Response is binary: setting metric to \"ks\" #> ℹ Using two-phase optimization #> ✔ Cross-validation score: 0.830886035159227 #> ℹ Performing two phase optimization #>  #> ── First phase ── #>  #> ℹ Sampling 0.1 and 1 of the dataset for the first phase #> ℹ Stratified sampling #> ℹ sampled 187 0s and 492 1s #>  #> ── Generate candidate kmers  #>  #> ── Regress each candidate kmer on sampled data  #> ℹ Running regression on 12 candidate kmers #> → regressing with seed: \"AAT*ATT\" #> → \"AAT*ATT\", score (r2): 0.591132168596821 #> → regressing with seed: \"GTTAAT\" #> → \"GTTAAT\", score (r2): 0.604879432766023 #> → regressing with seed: \"CTTATC\" #> → \"CTTATC\", score (r2): 0.340270238865439 #> → regressing with seed: \"TAAT*AT\" #> → \"TAAT*AT\", score (r2): 0.605634808074741 #> → regressing with seed: \"CTTATCT\" #> → \"CTTATCT\", score (r2): 0.388715363408895 #> → regressing with seed: \"TCTTATC\" #> → \"TCTTATC\", score (r2): 0.336555500560427 #> → regressing with seed: \"AAT*ATTA\" #> → \"AAT*ATTA\", score (r2): 0.607909926960762 #> → regressing with seed: \"TAAT*ATT\" #> → \"TAAT*ATT\", score (r2): 0.608690777008848 #> → regressing with seed: \"TAATCATT\" #> → \"TAATCATT\", score (r2): 0.604883777958721 #> → regressing with seed: \"AAGATAAC\" #> → \"AAGATAAC\", score (r2): 0.391166315606388 #> → regressing with seed: \"AAT*ATTAA\" #> → \"AAT*ATTAA\", score (r2): 0.612328728097362 #> → regressing with seed: \"TTAAT*ATT\" #> → \"TTAAT*ATT\", score (r2): 0.612328820509699 #> ℹ Best motif in the first phase: \"***TTAAT*ATT***\", score (r2): 0.612328820509699 #>  #> ── Phase 2: Running regression on the full dataset ── #>  #> ℹ Number of response variables: 1 #> ℹ Initializing regression with pre-computed PSSM #> ℹ Running regression #> • Motif length: 15 #> • Bidirectional: TRUE #> • Spat min: 0 #> • Spat max: 300 #> • Spat bin: 50 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> ✔ Finished running regression. Consensus: \"T*AM**W*Y\" #> ✔ KS test D: 0.8514, p-value: 0 res$score #>        D  #> 0.830886  res$cv_scores #>   fold1.D   fold2.D   fold3.D   fold4.D   fold5.D  #> 0.8045157 0.8475936 0.8744323 0.8470208 0.8309351   plot(res$cv_pred, res$full_model$pred, xlab = \"CV predictions\", ylab = \"Full model predictions\", cex = 0.1)  plot_regression_prediction_binary(res$cv_pred, cluster_mat_example[, 1])  plot_regression_prediction_binary(res$full_model$pred, cluster_mat_example[, 1])   # single phase res <- regress_pwm.cv(cluster_sequences_example, cluster_mat_example[, 1], nfolds = 5, two_phase = FALSE) #> ℹ Stratified sampling #> ℹ Response is binary: setting metric to \"ks\" #> ℹ Using single-phase optimization #> ✔ Cross-validation score: 0.831531608031667 #> ℹ Number of response variables: 1 #> ℹ Screening for kmers in order to initialize regression #> ℹ Number of response variables: 1 #> ℹ Screening kmers of length 8, from position 0 to position 300 #> ℹ minimal correlation: 0.08, minimal number of occurrences: 50 #> ✔ Found 198 kmers in 2359 sequences. #> ℹ Motif is shorter than 15, extending with wildcards #> ℹ Initializing regression with the following motif: \"***TAATCATT****\" #> ℹ Running regression #> • Motif length: 15 #> • Bidirectional: TRUE #> • Spat min: 0 #> • Spat max: 300 #> • Spat bin: 50 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> ✔ Finished running regression. Consensus: \"T*A***W*T\" #> ✔ KS test D: 0.8507, p-value: 0 res$score #>         D  #> 0.8315316  res$cv_scores #>   fold1.D   fold2.D   fold3.D   fold4.D   fold5.D  #> 0.8024361 0.8345217 0.8846364 0.8416589 0.8319746  plot(res$cv_pred, res$full_model$pred, xlab = \"CV predictions\", ylab = \"Full model predictions\", cex = 0.1)"},{"path":"/reference/regress_pwm.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform a PWM regression — regress_pwm","title":"Perform a PWM regression — regress_pwm","text":"Perform PWM regression","code":""},{"path":"/reference/regress_pwm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform a PWM regression — regress_pwm","text":"","code":"regress_pwm(   sequences,   response,   motif = NULL,   motif_length = 15,   score_metric = \"r2\",   bidirect = TRUE,   spat_min = 0,   spat_max = NULL,   spat_bin = 50,   spat_model = NULL,   improve_epsilon = 0.0001,   min_nuc_prob = 0.001,   unif_prior = 0.05,   is_train = NULL,   include_response = TRUE,   seed = 60427,   verbose = FALSE,   kmer_length = 8,   motif_num = 1,   consensus_single_thresh = 0.6,   consensus_double_thresh = 0.85,   match_with_db = FALSE,   ... )"},{"path":"/reference/regress_pwm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform a PWM regression — regress_pwm","text":"sequences vector DNA sequences ('', 'T', 'C' 'G'. go toupper) response matrix response variables - number rows equal number sequences motif Initial motif start regression . Can either string kmer character \"*\" indicates wildcard data frame pre-computed PSSM (see thre slot pssm return value function). NULL - K-mer screen performed order find best kmer initialization. motif_length Length seed motif. motif shorter , extended wildcards (stars). Note motif longer , truncated. score_metric metric use optimizing PWM. One \"r2\" \"ks\". using \"ks\" response variable single vector 0 1. bidirect motif bi-directional. TRUE, reverse-complement motif used well. spat_min start spatial model beginning sequence (bp) spat_max end spatial model beginning sequence (bp). NULL - spatial model end end sequence. spat_bin size spatial bin (bp). spat_model previously computed spatial model (see spat) return value function. can used motif previously computed PSSM. improve_epsilon minimum improve objective function continue optimization min_nuc_prob minimum nucleotide probability every iteration unif_prior uniform prior nucleotide probabilities is_train boolean vector determine subset sequences use screening include_response include response resulting list (default: TRUE) seed random seed verbose show verbose messages. kmer_length number non-gap characters motifs screened consensus_single_thresh, consensus_double_thresh thresholds consensus sequence calculation (single double nucleotides) match_with_db match resulting PWMs motif databases using pssm_match. Note closest match returned, even similar enough absolute terms. ... Arguments passed screen_kmers min_cor patterns maximum correlation one response variable larger min_cor reported min_n patterns average number occurrences sequences larger min_n reported min_gap,max_gap length gap considered pattern. one gap, length min_gap:max_gap, used, located anywhere motif. Note greatly expand search space (increase multiple tesing severly). from_range Sequences considered position from_range (default 0) to_range Sequences considered position to_range (default NULL - using length sequences) return_mat Return matrix patterns correlation response variables instead data frame. (default: FALSE)","code":""},{"path":"/reference/regress_pwm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform a PWM regression — regress_pwm","text":"list following elements: pssm: data frame pssm matrix inferred motif, rows positions columns nucleotides. spat: data frame inferred spatial model, spatial factor bin. pred: vector predicted pwm sequence. consensus: Consensus sequence based PSSM. response: response matrix. include_response FALSE, response matrix included list. r2: \\(r^2\\) prediction respect response variable. ks: response binary, Kolmogorov-Smirnov test results predictions response 1 vs predictions response 0. seed_motif: seed motif started regression. kmers: k-mers screened order find best seed motif (motif NULL).","code":""},{"path":"/reference/regress_pwm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform a PWM regression — regress_pwm","text":"","code":"res <- regress_pwm(sequences_example, response_mat_example) #> ℹ Number of response variables: 5 #> ℹ Screening for kmers in order to initialize regression #> ℹ Number of response variables: 5 #> ℹ Screening kmers of length 8, from position 0 to position 300 #> ℹ minimal correlation: 0.08, minimal number of occurrences: 50 #> ✔ Found 2138 kmers in 1000 sequences. #> ℹ Motif is shorter than 15, extending with wildcards #> ℹ Initializing regression with the following motif: \"***TTTACAAC****\" #> ℹ Running regression #> • Motif length: 15 #> • Bidirectional: TRUE #> • Spat min: 0 #> • Spat max: 300 #> • Spat bin: 50 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> ✔ Finished running regression. Consensus: \"TTACRAC\" #> ✔ R^2: 0.01, 0.0054, 0.0373, 0.0002, and 0.0087 res$pssm #>    pos            A            C            G            T #> 1    0 0.2095587850 0.1994811445 0.4830077589 0.1079523116 #> 2    1 0.1915405840 0.1868688613 0.3343640864 0.2872264385 #> 3    2 0.2101173997 0.1766019762 0.4432460964 0.1700345427 #> 4    3 0.1508440375 0.2343198955 0.0968408510 0.5179951787 #> 5    4 0.0008706285 0.2127699703 0.0008706285 0.7854887247 #> 6    5 0.0994162336 0.0010572918 0.0010095837 0.8985168934 #> 7    6 0.8009245396 0.0008999961 0.1971910000 0.0009845063 #> 8    7 0.0006821602 0.6252906919 0.0006821602 0.3733449876 #> 9    8 0.5259284377 0.0006187394 0.4273795187 0.0460732840 #> 10   9 0.8413030505 0.0011087267 0.1248238087 0.0327644646 #> 11  10 0.0484228246 0.6682083011 0.1590529233 0.1243159994 #> 12  11 0.1276983917 0.3283757865 0.0485897139 0.4953361154 #> 13  12 0.1383337379 0.2413944304 0.2644408643 0.3558309674 #> 14  13 0.1295451671 0.4627699852 0.2882918715 0.1193930283 #> 15  14 0.1975761950 0.2230612934 0.1874464601 0.3919161260 res$spat #>   bin spat_factor #> 1   0  0.06274135 #> 2  50  0.11854498 #> 3 100  0.08841380 #> 4 150  0.19018117 #> 5 200  0.24080996 #> 6 250  0.14966135 #> 7 300  0.14966135 head(res$pred) #> [1] -19.17809 -17.81525 -15.05438 -20.49352 -18.27786 -18.84269  plot_regression_qc(res) #> Warning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> = \"none\")` instead. #> Warning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> = \"none\")` instead.   # intialize with a pre-computed PSSM res1 <- regress_pwm(sequences_example, response_mat_example, motif = res$pssm) #> ℹ Number of response variables: 5 #> ℹ Initializing regression with pre-computed PSSM #> ℹ Running regression #> • Motif length: 15 #> • Bidirectional: TRUE #> • Spat min: 0 #> • Spat max: 300 #> • Spat bin: 50 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> ✔ Finished running regression. Consensus: \"TTACRAC\" #> ✔ R^2: 0.0105, 0.0056, 0.0363, 0.0001, and 0.01  # intialize with a pre-computed PSSM and spatial model res2 <- regress_pwm(sequences_example, response_mat_example, motif = res$pssm, spat_model = res$spat) #> ℹ Number of response variables: 5 #> ℹ Initializing regression with pre-computed PSSM #> ℹ Running regression #> • Motif length: 15 #> • Bidirectional: TRUE #> • Spat min: 0 #> • Spat max: 300 #> • Spat bin: 50 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> ✔ Finished running regression. Consensus: \"TTACRAC\" #> ✔ R^2: 0.0096, 0.0052, 0.0368, 0.0003, and 0.0085  # binary response res_binary <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1]) #> ℹ Number of response variables: 1 #> ℹ Screening for kmers in order to initialize regression #> ℹ Number of response variables: 1 #> ℹ Screening kmers of length 8, from position 0 to position 300 #> ℹ minimal correlation: 0.08, minimal number of occurrences: 50 #> ✔ Found 198 kmers in 2359 sequences. #> ℹ Motif is shorter than 15, extending with wildcards #> ℹ Initializing regression with the following motif: \"***TAATCATT****\" #> ℹ Running regression #> • Motif length: 15 #> • Bidirectional: TRUE #> • Spat min: 0 #> • Spat max: 300 #> • Spat bin: 50 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> ✔ Finished running regression. Consensus: \"T*A***W*T\" #> ✔ KS test D: 0.8507, p-value: 0 plot_regression_qc(res_binary) #> Warning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> = \"none\")` instead. #> Warning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> = \"none\")` instead.   # match with db res_binary <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1], match_with_db = TRUE) #> ℹ Number of response variables: 1 #> ℹ Screening for kmers in order to initialize regression #> ℹ Number of response variables: 1 #> ℹ Screening kmers of length 8, from position 0 to position 300 #> ℹ minimal correlation: 0.08, minimal number of occurrences: 50 #> ✔ Found 198 kmers in 2359 sequences. #> ℹ Motif is shorter than 15, extending with wildcards #> ℹ Initializing regression with the following motif: \"***TAATCATT****\" #> ℹ Running regression #> • Motif length: 15 #> • Bidirectional: TRUE #> • Spat min: 0 #> • Spat max: 300 #> • Spat bin: 50 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> ✔ Finished running regression. Consensus: \"T*A***W*T\" #> ℹ Best match in the database: \"HOMER.Hnf1\", KL: 0.34 #> ✔ \"HOMER.Hnf1\" KS test D: 0.8139, p-value: 0 #> ✔ KS test D: 0.8507, p-value: 0 plot_regression_qc(res_binary) #> Warning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> = \"none\")` instead. #> Warning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> = \"none\")` instead."},{"path":"/reference/regress_pwm.two_phase.html","id":null,"dir":"Reference","previous_headings":"","what":"Run a 2-phase PWM regression — regress_pwm.two_phase","title":"Run a 2-phase PWM regression — regress_pwm.two_phase","text":"first phase optimization performed sampled dataset size two_phase_sample_frac different candidates kmers regressed order find best seed. Thenm optimization performed full dataset initializing motif sampled dataset. can also give explicit indices sequences use first phase using first_phase_idxs.","code":""},{"path":"/reference/regress_pwm.two_phase.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run a 2-phase PWM regression — regress_pwm.two_phase","text":"","code":"regress_pwm.two_phase(   sequences,   response,   motif_length = 15,   score_metric = \"r2\",   bidirect = TRUE,   spat_min = 0,   spat_max = NULL,   spat_bin = 50,   improve_epsilon = 0.0001,   min_nuc_prob = 0.001,   unif_prior = 0.05,   is_train = NULL,   include_response = TRUE,   seed = 60427,   verbose = FALSE,   kmer_length = 6:8,   min_gap = 0,   max_gap = 1,   min_kmer_cor = 0.1,   consensus_single_thresh = 0.6,   consensus_double_thresh = 0.85,   two_phase_sample_frac = 0.1,   first_phase_idxs = NULL,   first_phase_metric = \"r2\",   parallel = getOption(\"prego.parallel\", FALSE),   match_with_db = FALSE,   ... )"},{"path":"/reference/regress_pwm.two_phase.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run a 2-phase PWM regression — regress_pwm.two_phase","text":"sequences vector DNA sequences ('', 'T', 'C' 'G'. go toupper) response matrix response variables - number rows equal number sequences is_train boolean vector determine subset sequences use screening seed random seed verbose verbosity second phase optimization. kmer_length vector kmer lengths screen order find best seed motif. min_gap, max_gap length gap considered pattern. one gap, length min_gap:max_gap, used, located anywhere motif. Note greatly expand search space (increase multiple tesing severly). two_phase_sample_frac fraction dataset sample first phase optimization (default: 0.1). response categorical (0 1), sampling stratified category, .e. two_phase_sample_frac can vector length 2 fraction 0 1 responses sample respectively. first_phase_idxs indices sequences use first phase optimization. NULL, indices sampled using two_phase_sample_frac. first_phase_metric metric use order choose best motif first phase optimization. One 'ks' 'r2'. Note unlike score_metric used regression , metric used choosing best motif first phase optimization runs sampled dataset. parallel whether run first phase optimization parallel. use set_parallel set number cores use.","code":""},{"path":"/reference/regress_pwm.two_phase.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run a 2-phase PWM regression — regress_pwm.two_phase","text":"list following elements: pssm: data frame pssm matrix inferred motif, rows positions columns nucleotides. spat: data frame inferred spatial model, spatial factor bin. pred: vector predicted pwm sequence. consensus: Consensus sequence based PSSM. response: response matrix. include_response FALSE, response matrix included list. r2: \\(r^2\\) prediction respect response variable. ks: response binary, Kolmogorov-Smirnov test results predictions response 1 vs predictions response 0. seed_motif: seed motif started regression. kmers: k-mers screened order find best seed motif (motif NULL).","code":""},{"path":"/reference/regress_pwm.two_phase.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run a 2-phase PWM regression — regress_pwm.two_phase","text":"","code":"res <- regress_pwm.two_phase(cluster_sequences_example, cluster_mat_example[, 1], two_phase_sample_frac = c(0.1, 1), first_phase_metric = \"ks\") #> ℹ Performing two phase optimization #>  #> ── First phase ── #>  #> ℹ Sampling 0.1 and 1 of the dataset for the first phase #> ℹ Stratified sampling #> ℹ sampled 187 0s and 492 1s #>  #> ── Generate candidate kmers  #>  #> ── Regress each candidate kmer on sampled data  #> ℹ Running regression on 12 candidate kmers #> ℹ Best motif in the first phase: \"***AAT*ATTAA***\", score (ks): 0.838485283248554 #>  #> ── Phase 2: Running regression on the full dataset ── #>  #> ℹ Number of response variables: 1 #> ℹ Initializing regression with pre-computed PSSM #> ℹ Running regression #> • Motif length: 15 #> • Bidirectional: TRUE #> • Spat min: 0 #> • Spat max: 300 #> • Spat bin: 50 #> • Improve epsilon: 0.0001 #> • Min nuc prob: 0.001 #> • Uniform prior: 0.05 #> • Score metric: \"r2\" #> • Seed: 60427 #> ✔ Finished running regression. Consensus: \"R*W**KT*A\" #> ✔ KS test D: 0.8514, p-value: 0 res$pssm #>    pos           A           C            G           T #> 1    0 0.245213479 0.199648947 0.3544846475 0.200652897 #> 2    1 0.229571313 0.229029343 0.2665824592 0.274816871 #> 3    2 0.206375405 0.314317167 0.2063754052 0.272932082 #> 4    3 0.552452564 0.026117221 0.3165676296 0.104862511 #> 5    4 0.422739089 0.323862046 0.0008286987 0.252570212 #> 6    5 0.385407656 0.001017793 0.1289312989 0.484643310 #> 7    6 0.180220529 0.296123028 0.2765798867 0.247076511 #> 8    7 0.529875934 0.001052755 0.2350929976 0.233978301 #> 9    8 0.001042730 0.143259510 0.2843351960 0.571362615 #> 10   9 0.001020463 0.217244446 0.0011460028 0.780589044 #> 11  10 0.531432629 0.160017207 0.1187699735 0.189780191 #> 12  11 0.713790655 0.060005266 0.2251836807 0.001020418 #> 13  12 0.223730654 0.474828452 0.1484422535 0.152998671 #> 14  13 0.242873088 0.316447675 0.1874947399 0.253184527 #> 15  14 0.264937550 0.247455552 0.2487054169 0.238901496 res$spat #>   bin spat_factor #> 1   0  0.05940168 #> 2  50  0.17209892 #> 3 100  0.19395736 #> 4 150  0.18225275 #> 5 200  0.15660921 #> 6 250  0.06358673 #> 7 300  0.17209892 head(res$pred) #> [1] -16.38393 -16.55559 -17.03628 -15.35067 -15.33256 -14.61532  plot_regression_qc(res) #> Warning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> = \"none\")` instead. #> Warning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> = \"none\")` instead."},{"path":"/reference/screen_kmers.html","id":null,"dir":"Reference","previous_headings":"","what":"Screen for kmers — screen_kmers","title":"Screen for kmers — screen_kmers","text":"Screen kmers","code":""},{"path":"/reference/screen_kmers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Screen for kmers — screen_kmers","text":"","code":"screen_kmers(   sequences,   response,   kmer_length = 6,   min_cor = 0.08,   min_n = 50,   is_train = NULL,   min_gap = 0,   max_gap = 0,   from_range = 0,   to_range = NULL,   return_mat = FALSE,   seed = 60427,   verbose = FALSE )"},{"path":"/reference/screen_kmers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Screen for kmers — screen_kmers","text":"sequences vector DNA sequences ('', 'T', 'C' 'G'. go toupper) response matrix response variables - number rows equal number sequences kmer_length number non-gap characters motifs screened min_cor patterns maximum correlation one response variable larger min_cor reported min_n patterns average number occurrences sequences larger min_n reported is_train boolean vector determine subset sequences use screening min_gap, max_gap length gap considered pattern. one gap, length min_gap:max_gap, used, located anywhere motif. Note greatly expand search space (increase multiple tesing severly). from_range Sequences considered position from_range (default 0) to_range Sequences considered position to_range (default NULL - using length sequences) return_mat Return matrix patterns correlation response variables instead data frame. (default: FALSE) seed random seed verbose show verbose messages","code":""},{"path":"/reference/screen_kmers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Screen for kmers — screen_kmers","text":"data frame following columns, together column response variable correlation kmers response variable: kmer: kmer pattern, \"*\" indicates wildcard, max_r2: maximum R^2 one response variables, avg_n: average number times kmer appears sequences, avg_var: variance number times kmer appears sequences, return_mat TRUE, matrix correlations response variables (rows kmers) returned instead data frame. kmer found, empty data frame returned.","code":""},{"path":"/reference/screen_kmers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Screen for kmers — screen_kmers","text":"","code":"kmers <- screen_kmers(sequences_example, response_mat_example) #> ℹ Number of response variables: 5 #> ℹ Screening kmers of length 6, from position 0 to position 300 #> ℹ minimal correlation: 0.08, minimal number of occurrences: 50 #> ✔ Found 575 kmers in 1000 sequences. head(kmers) #>     kmer     max_r2 avg_n    avg_var          c1          c2         c3 #> 1 AGATAA 0.04998882 0.140 0.15240000 -0.01025383 -0.03046725 -0.2235818 #> 2 TTATCT 0.02975253 0.128 0.13761599  0.03136108  0.04927359 -0.1724892 #> 3 CTTATC 0.02680831 0.080 0.07960001  0.02861430  0.01967959 -0.1637324 #> 4 GGGGAG 0.02300140 0.243 0.28195098  0.04611732  0.02960520  0.1516621 #> 5 GGGCGG 0.02280306 0.062 0.06015600  0.06576437  0.02662074  0.1510068 #> 6 TAACTG 0.02215597 0.071 0.06995900 -0.01145993 -0.02249238 -0.1488488 #>             c4          c5 #> 1  0.004382457 -0.03498838 #> 2  0.035843253  0.02917432 #> 3  0.059437271  0.03772539 #> 4  0.044013925  0.03089626 #> 5  0.104473867  0.12732512 #> 6 -0.037136175 -0.01858661  kmers <- screen_kmers(sequences_example, response_mat_example, return_mat = TRUE) #> ℹ Number of response variables: 5 #> ℹ Screening kmers of length 6, from position 0 to position 300 #> ℹ minimal correlation: 0.08, minimal number of occurrences: 50 #> ✔ Found 575 kmers in 1000 sequences. head(kmers) #>                 c1          c2         c3           c4          c5 #> AGATAA -0.01025383 -0.03046725 -0.2235818  0.004382457 -0.03498838 #> TTATCT  0.03136108  0.04927359 -0.1724892  0.035843253  0.02917432 #> CTTATC  0.02861430  0.01967959 -0.1637324  0.059437271  0.03772539 #> GGGGAG  0.04611732  0.02960520  0.1516621  0.044013925  0.03089626 #> GGGCGG  0.06576437  0.02662074  0.1510068  0.104473867  0.12732512 #> TAACTG -0.01145993 -0.02249238 -0.1488488 -0.037136175 -0.01858661  kmers <- screen_kmers(sequences_example, response_mat_example, max_gap = 3) #> ℹ Number of response variables: 5 #> ℹ Screening kmers of length 6, from position 0 to position 300 #> ℹ Gaps of length 0:3 are allowed #> ℹ minimal correlation: 0.08, minimal number of occurrences: 50 #> ✔ Found 4884 kmers in 1000 sequences. head(kmers) #>       kmer     max_r2 avg_n    avg_var           c1           c2         c3 #> 1   AGATAA 0.05012437 0.139 0.15167901 -0.011159671 -0.033565160 -0.2238847 #> 2  AGA*AAG 0.03404951 0.220 0.23760001  0.062884174  0.063842162 -0.1845251 #> 3   TTATCT 0.02915060 0.127 0.13487099  0.036021627  0.051995803 -0.1707355 #> 4 ACAT**CT 0.02848161 0.090 0.09190000 -0.002383306 -0.023468828 -0.1687650 #> 5  AG*TAAG 0.02829135 0.118 0.12007600  0.034630746 -0.005794165 -0.1682003 #> 6   CTTATC 0.02680831 0.080 0.07960001  0.028614303  0.019679585 -0.1637324 #>            c4          c5 #> 1 0.001539792 -0.03616555 #> 2 0.025056362  0.02373981 #> 3 0.032191906  0.02568413 #> 4 0.019714575 -0.02059141 #> 5 0.046150818  0.02593128 #> 6 0.059437271  0.03772539"},{"path":"/reference/set_parallel.html","id":null,"dir":"Reference","previous_headings":"","what":"Set parallel threads — set_parallel","title":"Set parallel threads — set_parallel","text":"Set number parallel threads use. prego uses R function doMC::registerDoMC register parallelization. default, prego uses 80% number available cores. options saved 'prego.parallel' (use parallelization, logical) 'prego.parallel.nc' (number cores use, integer).","code":""},{"path":"/reference/set_parallel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set parallel threads — set_parallel","text":"","code":"set_parallel(thread_num = max(1, round(parallel::detectCores() * 0.8)))"},{"path":"/reference/set_parallel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set parallel threads — set_parallel","text":"thread_num number threads. use '1' non parallel behavior","code":""},{"path":"/reference/set_parallel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set parallel threads — set_parallel","text":"None","code":""},{"path":"/reference/set_parallel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set parallel threads — set_parallel","text":"","code":"# \\donttest{ set_parallel(8) #> ℹ Parallelization enabled. Using 8 threads. # }"}]
