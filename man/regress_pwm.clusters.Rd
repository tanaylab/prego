% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/regression-clusters.R
\name{regress_pwm.clusters}
\alias{regress_pwm.clusters}
\title{Run PWM regression on clusters}
\usage{
regress_pwm.clusters(
  sequences,
  clusters,
  two_phase = FALSE,
  match_with_db = TRUE,
  two_phase_sample_frac = c(0.1, 1),
  first_phase_metric = "ks",
  parallel = getOption("prego.parallel", TRUE),
  ...
)
}
\arguments{
\item{sequences}{A vector of DNA sequences ('A', 'T', 'C' or 'G'. Will go through \code{toupper})}

\item{clusters}{a vector with the cluster assignments for each sequence}

\item{two_phase}{whether to use two-phase optimization or not (default: FALSE).}

\item{match_with_db}{match the resulting PWMs with motif databases using \code{pssm_match}.
This would add a column named 'db_match' to the stats data frame, together with 'pred_mat_db' with the
database motif predictions, and and 'db_dataset' which is similiar to 'motif_dataset' for the database motifs.
Note that the closest match is returned, even if it is not similar enough in absolute terms.}

\item{two_phase_sample_frac}{a vector of two numbers, specifying the fraction of
sequences to use in the first phase of optimization for the sequences which are not
in the cluster (first number) and in the cluster (second number).}

\item{first_phase_metric}{metric to use in order to choose the best motif in the first phase of the optimization. One of 'ks' or 'r2'. Note that unlike \code{score_metric} which is used in the regression itself, this metric is used only for choosing the best motif in the first phase of the optimization out of all the runs on the sampled dataset.}

\item{parallel}{whether to run the first phase of the optimization in parallel. use \code{set_parallel}
to set the number of cores to use.}

\item{...}{
  Arguments passed on to \code{\link[=regress_pwm]{regress_pwm}}, \code{\link[=regress_pwm.two_phase]{regress_pwm.two_phase}}
  \describe{
    \item{\code{response}}{A matrix of response variables - number of rows should equal the number of sequences}
    \item{\code{motif}}{Initial motif to start the regression from. Can be either a string with a kmer where the character "*" indicates a
wildcard or a data frame with a pre-computed PSSM (see thre slot \code{pssm} in the return value of this function).
If NULL - a K-mer screen would be performed in order to find the best kmer for initialization.}
    \item{\code{motif_length}}{Length of the seed motif. If the motif is shorter than this, it will be extended by wildcards (stars). Note that If the motif is longer than this, it will \emph{not} be truncated.}
    \item{\code{score_metric}}{metric to use for optimizing the PWM. One of "r2" or "ks". When using "ks" the response variable should be a single vector of 0 and 1.}
    \item{\code{bidirect}}{is the motif bi-directional. If TRUE, the reverse-complement of the motif will be used as well.}
    \item{\code{spat_min}}{start of the spatial model from the beginning of the sequence (in bp)}
    \item{\code{spat_max}}{end of the spatial model from the beginning of the sequence (in bp). If NULL - the spatial model
would end at the end of the sequence.}
    \item{\code{spat_bin}}{size of the spatial bin (in bp).}
    \item{\code{spat_model}}{a previously computed spatial model (see \code{spat}) in the return value of this function. This can only be used when \code{motif} is a previously computed PSSM.}
    \item{\code{improve_epsilon}}{minimum improve in the objective function to continue the optimization}
    \item{\code{min_nuc_prob}}{minimum nucleotide probability in every iteration}
    \item{\code{unif_prior}}{uniform prior for nucleotide probabilities}
    \item{\code{include_response}}{include the response in the resulting list (default: TRUE)}
    \item{\code{verbose}}{show verbose messages.}
    \item{\code{seed}}{random seed}
    \item{\code{consensus_single_thresh,consensus_double_thresh}}{thresholds for the consensus sequence calculation
(single and double nucleotides)}
    \item{\code{motif_dataset}}{a data frame with PSSMs ('A', 'C', 'G' and 'T' columns), with an additional column 'motif' containing the motif name, for example \code{HOMER_motifs}, \code{JASPAR_motifs} or all_motif_datasets(). By default all_motif_datasets() would be used.}
    \item{\code{kmer_length}}{The number of non-gap characters in motifs that will be screened}
    \item{\code{is_train}}{a boolean vector that determine which subset of sequences to use when screening}
    \item{\code{first_phase_idxs}}{indices of the sequences to use in the first phase of the optimization. If NULL, the indices would be sampled using \code{two_phase_sample_frac}.}
    \item{\code{min_gap,max_gap}}{the length of a gap to be considered in the pattern. Only one gap, of length min_gap:max_gap, is being used, and is located anywhere in the motif. Note that this greatly expand the search space (and increase multiple tesing severly).}
  }}
}
\value{
a list with the following elements:
\itemize{
\item{models: }{a list with the models for each cluster}
\item{cluster_mat: }{an indicator matrix with the cluster assignments}
\item{pred_mat: }{a matrix with the predicted pwm for each sequence (rows) and cluster (columns)}
\item{motif_dataset: }{a data frame with the PSSMs for each cluster}
\item{spat_dataset: }{a data frame with the spatial model for each cluster}
\item{stats: }{a data frame with statistics for each cluster}
}
}
\description{
Run PWM regression on clusters
}
\examples{
res <- regress_pwm.clusters(cluster_sequences_example, clusters_example)
head(res$pred_mat)
res$stats

plot_regression_qc(res$models[[1]], title = names(res$models)[1])

}
