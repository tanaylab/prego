% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/regression.R
\name{regress_pwm}
\alias{regress_pwm}
\title{Perform a PWM regression}
\usage{
regress_pwm(
  sequences,
  response,
  motif = NULL,
  motif_length = 15,
  score_metric = "r2",
  bidirect = TRUE,
  spat_min = 0,
  spat_max = NULL,
  spat_bin = 50,
  spat_model = NULL,
  improve_epsilon = 0.0001,
  min_nuc_prob = 0.001,
  unif_prior = 0.05,
  is_train = NULL,
  include_response = TRUE,
  seed = 60427,
  verbose = FALSE,
  kmer_length = 8,
  multi_kmers = FALSE,
  final_metric = "r2",
  max_cands = 10,
  min_gap = 0,
  max_gap = 1,
  min_kmer_cor = 0.1,
  motif_num = 1,
  smooth_k = 100,
  consensus_single_thresh = 0.6,
  consensus_double_thresh = 0.85,
  match_with_db = FALSE,
  motif_dataset = all_motif_datasets(),
  parallel = getOption("prego.parallel", FALSE),
  ...
)
}
\arguments{
\item{sequences}{A vector of DNA sequences ('A', 'T', 'C' or 'G'. Will go through \code{toupper})}

\item{response}{A matrix of response variables - number of rows should equal the number of sequences}

\item{motif}{Initial motif to start the regression from. Can be either a string with a kmer where the character "*" indicates a
wildcard or a data frame with a pre-computed PSSM (see the slot \code{pssm} in the return value of this function).
If NULL - a K-mer screen would be performed in order to find the best kmer for initialization.}

\item{motif_length}{Length of the seed motif. If the motif is shorter than this, it will be extended by wildcards (stars). Note that If the motif is longer than this, it will \emph{not} be truncated.}

\item{score_metric}{metric to use for optimizing the PWM. One of "r2" or "ks". When using "ks" the response variable should be a single vector of 0 and 1.}

\item{bidirect}{is the motif bi-directional. If TRUE, the reverse-complement of the motif will be used as well.}

\item{spat_min}{start of the spatial model from the beginning of the sequence (in bp)}

\item{spat_max}{end of the spatial model from the beginning of the sequence (in bp). If NULL - the spatial model
would end at the end of the sequence.}

\item{spat_bin}{size of the spatial bin (in bp).}

\item{spat_model}{a previously computed spatial model (see \code{spat}) in the return value of this function. This can only be used when \code{motif} is a previously computed PSSM.}

\item{improve_epsilon}{minimum improve in the objective function to continue the optimization}

\item{min_nuc_prob}{minimum nucleotide probability in every iteration}

\item{unif_prior}{uniform prior for nucleotide probabilities}

\item{is_train}{a boolean vector that determine which subset of sequences to use when screening}

\item{include_response}{include the response in the resulting list (default: TRUE)}

\item{seed}{random seed}

\item{verbose}{show verbose messages.}

\item{kmer_length}{a vector of kmer lengths to screen in order to find the best seed motif.}

\item{multi_kmers}{if TRUE, different candidates of kmers would be regressed in order to find the best seed according to \code{final_metric}.}

\item{final_metric}{metric to use in order to choose the best motif. One of 'ks' or 'r2'. Note that unlike \code{score_metric} which is used in the regression itself, this metric is used only for choosing the best motif out of all the runs on the sampled dataset.}

\item{max_cands}{maximum number of kmer candidates to try.}

\item{min_gap, max_gap}{the length of a gap to be considered in the pattern. Only one gap, of length min_gap:max_gap, is being used, and is located anywhere in the motif. Note that this greatly expand the search space (and increase multiple testing severely).}

\item{min_kmer_cor}{minimal correlation between the kmer and the response in order to use it as a seed.}

\item{motif_num}{Number of motifs to infer. When \code{motif_num} > 1, the function would run \code{motif_num} times, each time on the residuals of a linear model of all the previous runs (see \code{smooth_k} parameter). The best motif is then returned, while all the others are stored at 'models' in the return value.}

\item{smooth_k}{k for smoothing the predictions of each model in order to compute the residuals when \code{motif_num} > 1. The residuals are computed as \code{response} - running mean of size 'k' of the current model.}

\item{consensus_single_thresh, consensus_double_thresh}{thresholds for the consensus sequence calculation
(single and double nucleotides)}

\item{match_with_db}{match the resulting PWMs with motif databases using \code{pssm_match}. Note that the closest match
is returned, even if it is not similar enough in absolute terms.}

\item{motif_dataset}{a data frame with PSSMs ('A', 'C', 'G' and 'T' columns), with an additional column 'motif' containing the motif name, for example \code{HOMER_motifs}, \code{JASPAR_motifs} or all_motif_datasets(). By default all_motif_datasets() would be used.}

\item{parallel}{whether to run optimization in parallel. use \code{set_parallel}
to set the number of cores to use.}

\item{...}{
  Arguments passed on to \code{\link[=screen_kmers]{screen_kmers}}
  \describe{
    \item{\code{min_cor}}{Only patterns for which the maximum correlation to one of the response variable is larger than min_cor will be reported}
    \item{\code{min_n}}{Only patterns for which the average number of occurrences in the sequences is larger than min_n will be reported}
    \item{\code{min_gap,max_gap}}{the length of a gap to be considered in the pattern. Only one gap, of length min_gap:max_gap, is being used, and is located anywhere in the motif. Note that this greatly expand the search space (and increase multiple testing severely).}
    \item{\code{from_range}}{Sequences will be considered only from position from_range (default 0)}
    \item{\code{to_range}}{Sequences will be considered only up to position to_range (default NULL - using the length of the sequences)}
    \item{\code{return_mat}}{Return a matrix of patterns and their correlation to the response variables instead of a data frame. (default: FALSE)}
  }}
}
\value{
a list with the following elements:
\itemize{
\item{pssm: }{data frame with the pssm matrix with the inferred motif, where rows are positions and columns are nucleotides.}
\item{spat: }{a data frame with the inferred spatial model, with the spatial factor for each bin.}
\item{pred: }{a vector with the predicted pwm for each sequence.}
\item{consensus: }{Consensus sequence based on the PSSM.}
\item{response: }{The response matrix. If \code{include_response} is FALSE, the response matrix is not included in the list.}
\item{r2: }{\eqn{r^2} of the prediction with respect to the each response variable.}
\item{ks: }{If response is binary, Kolmogorov-Smirnov test results of the predictions where the response was 1 vs the predictions where the response was 0.}
\item{seed_motif: }{The seed motif that started the regression.}
\item{kmers: }{The k-mers that were screened in order to find the best seed motif (if motif was NULL).}
\item{sample_idxs: }{The indices of the sequences that were used for the regression (only for \code{regress_pwm.sample}).}
}

When \code{match_with_db} is TRUE, the following additional elements are returned:
\itemize{
\item{motif_db: }{The motif database that the most similar to the resulting PSSM.}
\item{db_match_dist: }{The distance between the resulting PSSM and the closest match in the motif database (KL divergence).}
\item{db_match_pssm: }{The PSSM of the closest match in the motif database.}
\item{db_match_pred: }{The predicted PWM of the closest match in the motif database.}
\item{db_match_r2: }{The \eqn{r^2} of the predicted PWM of the closest match in the motif database and the response}
\item{db_match_ks: }{If response is binary, the Kolmogorov-Smirnov test results of the predicted PWM of the closest match in the motif database where the response was 1 vs the predictions where the response was 0.}
}

When \code{n_motifs} is greater than 1, the following additional elements are returned:
\itemize{
\item{models: }{A list (as above) of each inferred model}
\item{multi_stats: }{A data frame with the following columns: \code{model}, \code{score} (KS for binary, r^2 otherwise), \code{comb_score} (score for the combined linear model for models 1:i) and additional statistics per model}
}
}
\description{
Perform a PWM regression
}
\examples{
\dontrun{
res <- regress_pwm(sequences_example, response_mat_example)
res$pssm
res$spat
head(res$pred)

plot_regression_qc(res)

# intialize with a pre-computed PSSM
res1 <- regress_pwm(sequences_example, response_mat_example, motif = res$pssm)

# intialize with a pre-computed PSSM and spatial model
res2 <- regress_pwm(
    sequences_example,
    response_mat_example,
    motif = res$pssm,
    spat_model = res$spat
)

# binary response
res_binary <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1])
plot_regression_qc(res_binary)

# match with db
res_binary <- regress_pwm(cluster_sequences_example, cluster_mat_example[, 1], match_with_db = TRUE)
plot_regression_qc(res_binary)

# use multiple kmer seeds
res_multi <- regress_pwm(
    cluster_sequences_example,
    cluster_mat_example[, 1],
    multi_kmers = TRUE,
    kmer_length = 6:8,
    final_metric = "ks"
)
plot_regression_qc(res_multi)

# Screen for multiple motifs
res_multi <- regress_pwm(
    cluster_sequences_example,
    cluster_mat_example[, 1],
    motif_num = 3,
    match_with_db = TRUE
)
res_multi$multi_stats
plot_regression_qc_multi(res_multi)
}

}
