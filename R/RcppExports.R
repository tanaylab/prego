# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

n_nuc_distribution <- function(sequences, n, size = 1000L) {
    .Call('_prego_n_nuc_distribution', PACKAGE = 'prego', sequences, n, size)
}

calc_sequences_dinuc_cpp <- function(sequences) {
    .Call('_prego_calc_sequences_dinuc_cpp', PACKAGE = 'prego', sequences)
}

kmer_matrix_cpp <- function(sequences, kmer_length, from_range = 0L, to_range = NULL, mask = NULL, add_mask = FALSE, max_gap = 0L) {
    .Call('_prego_kmer_matrix_cpp', PACKAGE = 'prego', sequences, kmer_length, from_range, to_range, mask, add_mask, max_gap)
}

calc_seq_pwm_parallel_cpp <- function(sequences, pwm, pwm_rc, motif_lengths, D_min = 1L, bidirect = FALSE, spat_factors = matrix(0), spat_bin_size = 1L) {
    .Call('_prego_calc_seq_pwm_parallel_cpp', PACKAGE = 'prego', sequences, pwm, pwm_rc, motif_lengths, D_min, bidirect, spat_factors, spat_bin_size)
}

get_consensus_cpp <- function(pssm_mat, single_thresh, double_thresh) {
    .Call('_prego_get_consensus_cpp', PACKAGE = 'prego', pssm_mat, single_thresh, double_thresh)
}

compute_pwm_cpp <- function(sequences, pssm_mat, is_bidirect, spat_min, spat_max, spat_factor, bin_size, use_max = FALSE) {
    .Call('_prego_compute_pwm_cpp', PACKAGE = 'prego', sequences, pssm_mat, is_bidirect, spat_min, spat_max, spat_factor, bin_size, use_max)
}

compute_local_pwm_cpp <- function(sequences, pssm_mat, is_bidirect, spat_min, spat_max, spat_factor, bin_size) {
    .Call('_prego_compute_local_pwm_cpp', PACKAGE = 'prego', sequences, pssm_mat, is_bidirect, spat_min, spat_max, spat_factor, bin_size)
}

mask_sequences_cpp <- function(sequences, pssm_mat, is_bidirect, spat_min, spat_max, spat_factor, bin_size, mask_thresh, pos_mask) {
    .Call('_prego_mask_sequences_cpp', PACKAGE = 'prego', sequences, pssm_mat, is_bidirect, spat_min, spat_max, spat_factor, bin_size, mask_thresh, pos_mask)
}

regress_pwm_cpp <- function(sequences, response, is_train_logical, motif, spat_min, spat_max, min_nuc_prob, spat_bin, improve_epsilon, is_bidirect, unif_prior, score_metric, verbose, seed, pssm_mat, spat_factor, consensus_single_thresh, consensus_double_thresh, num_folds = 1L, energy_epsilon = 0, log_energy = FALSE, energy_func = NULL, xmin = -100, xmax = 100, npts = 1000L, optimize_pwm = TRUE, optimize_spat = TRUE, symmetrize_spat = TRUE) {
    .Call('_prego_regress_pwm_cpp', PACKAGE = 'prego', sequences, response, is_train_logical, motif, spat_min, spat_max, min_nuc_prob, spat_bin, improve_epsilon, is_bidirect, unif_prior, score_metric, verbose, seed, pssm_mat, spat_factor, consensus_single_thresh, consensus_double_thresh, num_folds, energy_epsilon, log_energy, energy_func, xmin, xmax, npts, optimize_pwm, optimize_spat, symmetrize_spat)
}

screen_kmers_cpp <- function(sequences, response, is_train_logical, L, from_range, to_range, min_cor, min_gap, max_gap, n_in_train, seed, verbose) {
    .Call('_prego_screen_kmers_cpp', PACKAGE = 'prego', sequences, response, is_train_logical, L, from_range, to_range, min_cor, min_gap, max_gap, n_in_train, seed, verbose)
}

interpolateFunction <- function(func, xmin, xmax, npts, x) {
    .Call('_prego_interpolateFunction', PACKAGE = 'prego', func, xmin, xmax, npts, x)
}

rc_cpp <- function(sequences) {
    .Call('_prego_rc_cpp', PACKAGE = 'prego', sequences)
}

